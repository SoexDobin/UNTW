!데이터타입
!정적타입, 동적타입 (비교연산자)
! String, Number 생성자 함수
!!논리연산자, 단축평가
!! null 동적 메모리 확인
!!객체리터럴 - value, key value같으면 생략가능
!! 원시값과 객체비교
!! shallow deep copy
!!함수 리터럴 표현식
!!그룹연산자 함수리터럴
!생성자, 화살표 함수
!! 중첩함수 
!!callback함수 - 서비스, 클라 구별, 콜백 기능 구별
!스코프 -  원시값의 스코프 범위 함수레벨 스코프 범위
!!생성자함수 - new로 생성자 호출할때와 그냥 호출시 차이점 return
!!모든 객체의 최상위 프로토타입 객체는 object.prototype이다.
+ 프로토타입 상속 구성



* 자바스크립트가 하는 일
  - html, css 추가 삭제 변경
  - 원격 서버 요청
  - 사용자 이벤트 반응
  - 브라우저 안에서 데이터 읽고 쓰기
  + Node.exe 자바스크립트로 외부에서 작용

* 변수 선언 방식
  - var 
  - let (변수 정리)
  - const (상수 정리)

**암기하기★**
* 데이터 내장 타입 (단일 값)
  - 숫자타입 number
  - 문자열타입 string
  - 불린 boolen
  - undefined (초기화X)
  - null (값이 없다, 참조 제거)
  - symbol (유니크한 어떤 private값 == key)
  - bigint(컴퓨터가 인식하는 이상의 숫자)
* 객체 타입 (다양한 값)
  - object
**암기하기★**
* 정적 타입
  - 무조건 같은 타입만을 받음
  - char, string
* 동적 타입
  - ★동적 타입을 참조 형식으로 값을 할당함
  - 변수를 보고 타입을 판단 함
  - 가비지 컬렉터가 버려진 참조 형태의 변수를 알아서 제거해줌 
  - let, const, var

* 문 statement
  - ~문과 표현식으로 이루어짐
  - 초기화가 되는 변수가 있는 문은 표현식
  - 단지 아무것도 받지않고 선언만하면 문이라함 ex.함수문 var문

 * 형변환 
 ``` javascript
console.log("" + 1 + 0);    // "10"
console.log("" - 1 + 0);    // -1
console.log(true + false);  // 1
console.log(6 / "3");       // 2
console.log("2" * "3");     // 6
console.log(4 + 5 + "px");  // "9px"
console.log("$" + 4 + 5);   // $45
console.log("4" - 2);       // 2
console.log("4px" - 2);     // NaN★★★
console.log(7 / 0);         // Infinity★★★
console.log("  -9  " + 5);  // "  -9  5"
console.log("  -9  " - 5);  // -14
console.log(null + 1);      // 1
console.log(undefined + 1); // NaN
console.log(" \t \n" - 2);  // -2

let n = 10;
console.log(+n);            // 10
console.log(-n);            // -10
console.log(+Infinity);     // Infinity
console.log(-Infinity);     // -Infinity
console.log(+"10" + 1);     // 11★★★
console.log("10" * 1 + 1);  // 11★★★
 ```

 * 비교연산자
  - ++a 문장을 실행하며 증가 a++ 문장이 끝나고 난후 증가
  - == 값이 같은가?
  - === 값과 타입이 같은가?

* 3항 연산식
```javascript
var x = 2;

// 0은 false로 취급된다.
var result = x % 2 ? '홀수' : '짝수';
```
```javascript
var num = 2;

// 0은 false로 취급된다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';

console.log(kind); // 양수
```

* switch문
```javascript
// 월을 영어로 변환한다. (11 → 'November')
var month = 11;
var monthName;

switch (month) {
  case 1: monthName = 'January'; break;
  case 2: monthName = 'February'; break;
  case 3: monthName = 'March'; break;
  case 4: monthName = 'April'; break;
  case 5: monthName = 'May'; break;
  case 6: monthName = 'June'; break;
  case 7: monthName = 'July'; break;
  case 8: monthName = 'August'; break;
  case 9: monthName = 'September'; break;
  case 10: monthName = 'October'; break;
  case 11: monthName = 'November'; break;
  case 12: monthName = 'December'; break;
  default: monthName = 'Invalid month';
  case a: case: b case: c days = 30; break; //중복도 가능
}
console.log(monthName); // November
```
* for문
```javascript
// 무한루프
for (;;) { ... }

//중첩 for문
for (var i = 1; i <= 6; i++) {
  for (var j = 1; j <= 6; j++) {
    if (i + j === 6) console.log(`[${i}, ${j}]`);
  }
}
```

while문
```javascript
// 무한루프
while (true) {
  console.log(count);
  count++;
  if (count === 3) break; 
  // 타입과 값이 같으면
}

var count = 0;

// do while문 값이 false여도 무조건 1번 실행됨
// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
// false 값이더라도 1번은 돌아감
var count = 10;
do {
  console.log(count);
  count++;
} while (count < 3);
//
```
foo레이블 식별자
```javascript
// foo라는 식별자가 붙은 레이블 블록문
foo: {
  console.log(1);
  break foo; // foo 레이블 블록문을 탈출한다.
  console.log(2); //실행 안됨!
}
```
foo를 outer라고 쓴것 뿐임 위에랑 같은 방식 탈출코드
```javascript
// outer라는 식별자가 붙은 레이블 for 문
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.
    if (i + j === 3) break outer;
    console.log(`inner [${i}, ${j}]`);
  }
}

console.log('Done!');
```
```javascript
var string = 'Hello World.';
var search = 'l';
var index;

// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.
for (var i = 0; i < string.length; i++) {
  // 문자열의 개별 문자가 'l'이면
  if (string[i] === search) {
    index = i;
    break; // 반복문을 탈출한다.
  }
}
console.log(index); // 2
//================================================================
// 참고로 String.prototype.indexOf 메서드를 사용해도 같은 동작을 한다.
console.log(string.indexOf(search)); // 2
```
console.log(String(string).indexOf(search)); 부모가 만들어놓은 객체
를 우리는 console.log(string.indexOf(search)); 이렇게 써서 불러오고
indexof메소드를 사용하게 된다.
**(.)연산자를 통한 멤버접근 래퍼객체**★★★

**String 생성자 함수 ★★**
```javascript
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
// 숫자 타입 => 문자열 타입
String(1);        // -> "1"
String(NaN);      // -> "NaN"
String(Infinity); // -> "Infinity"
// 불리언 타입 => 문자열 타입
String(true);     // -> "true"
String(false);    // -> "false"

// 2. Object.prototype.toString 메서드를 사용하는 방법
// 숫자 타입 => 문자열 타입
(1).toString();        // -> "1"
(NaN).toString();      // -> "NaN"
(Infinity).toString(); // -> "Infinity"
// 불리언 타입 => 문자열 타입
(true).toString();     // -> "true"
(false).toString();    // -> "false"

// 3. 문자열 연결 연산자를 이용하는 방법
// 숫자 타입 => 문자열 타입
1 + '';        // -> "1"
NaN + '';      // -> "NaN"
Infinity + ''; // -> "Infinity"
// 불리언 타입 => 문자열 타입
true + '';     // -> "true"
false + '';    // -> "false"
```
**Number 생성자 함수 ★★**
```javascript
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0');     // -> 0
Number('-1');    // -> -1
Number('10.53'); // -> 10.53
// 불리언 타입 => 숫자 타입
Number(true);    // -> 1
Number(false);   // -> 0

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
// 문자열 타입 => 숫자 타입
parseInt('0');       // -> 0 ★★
parseInt('-1');      // -> -1 ★★
parseFloat('10.53'); // -> 10.53 ★★

// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
+'0';     // -> 0
+'-1';    // -> -1
+'10.53'; // -> 10.53
// 불리언 타입 => 숫자 타입
+true;    // -> 1
+false;   // -> 0

// 4. * 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
'0' * 1;     // -> 0
'-1' * 1;    // -> -1
'10.53' * 1; // -> 10.53
// 불리언 타입 => 숫자 타입
true * 1;    // -> 1
false * 1;   // -> 0
```

**논리연산자★★★★★**
&& 단축평가
And연산자는 앞이false면 뒤를 확인 안함
|| 단락평가
or연산자는 앞이true면 뒤를 확인 안함
```javascript
"Cat" && "Dog" //-> "Dog"
"Cat" || "Dog" //-> "Cat"
```
**null통한 동적메모리 확인★★★**
```javascript
var elem = null;
// elem이 null이나 undefined와 같은 Falsy 값이면 elem으로 평가되고
// elem이 Truthy 값이면 elem.value로 평가된다.
var value = elem && elem.value; // -> null
//===================================================================
var elem = null;

// elem이 null 또는 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
var value = elem?.value;
console.log(value); // undefined
//===================================================================
// 좌항의 피연산자가 null 또는 undefined이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
var foo = null ?? 'default string';
console.log(foo); // "default string"
```
## 객체생성방법
  - 객체 리터럴
  - object생성자 함수
  - object.create()메서드
  - 사용자 생성자 함수
  - 클래스 사용하는 방법

**객체 리터럴**
```javascript
var person = {
  name: 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  }
};

console.log(typeof person); // object
console.log(person); // {name: "Lee", sayHello: ƒ}
//{ property key : property value }로 쓰면됨
// {} 리터럴 객체라고 함
// 함수를 객체로 가지게 되면 메서드라고 부름
```
* delete 소멸자
```javascript
var person = {
  name: 'Lee'
};

// 프로퍼티 동적 생성
person.age = 20;

// person 객체에 age 프로퍼티가 존재한다.
// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있다.
delete person.age;

// person 객체에 address 프로퍼티가 존재하지 않는다.
// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.
delete person.address;

console.log(person); // {name: "Lee"}
```

* **시험★★★★★**
```javascript
// ES5
var x = 1, y = 2; // value 부분
 
var obj1 = { x: x, y: y }; //key부분
var obj2 = { x, y };

console.log(obj1); // {x: 1, y: 2}
console.log(obj2); // {x: 1, y: 2} 익스6이상부터 지원
//key와 value가 같으면 생략을 통해 사용가능
```
* 템플릿 문자열
```javascript
const prefix = 'prop';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i };

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 원시값과 객체의 비교
**시험★★★★★**   

![원시 변수 값변경](https://user-images.githubusercontent.com/56966606/161897422-c31cb3d7-42a6-4ba0-8a56-76f14f2b737d.png)
* 변수 값 변경은 값이 갈아치워지는게 아닌 다른메모리에 할당된 변수로 주소가 참조 되는 것이다.
* 원시값은 얕은 복사도 깊은 복사 "취급"으로 받아들여진다.
* 객체의 경우에는 얕은 복사로 받아들여 진다.
```javascript
const v = 1;
const r = v;
console.log(v === r);
const obj = { name : 1};
const obj2 = obj;
console.log(obj === obj2);
```
* 둘다 같은 메모리를 참조하고있는 상태여서 값과 타입 같다.
* 결국 원시값은 값이 같으면 true 객체는 타입인 참조도 같아야 true복사형태이다.
![shallow deep copy](https://user-images.githubusercontent.com/56966606/161899008-c31ebbe5-da53-403d-b2f4-0b8ced601b81.png)

**시험★★★★★**   
* 원시값과 객체의 구별방법
1. 복사 방법
2. 비교 형태
```javascript
const o = { x: { y: 1 } }; // 2번에 걸쳐 옅은복사 참조

// 얕은 복사
const c1 = { ...o }; 
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
// 스프레드 문법으로 객체 메모리가 복사되지만 또다른 프로퍼티가key 값으로 오면 한게를 마주한다.

// 깊은 복사
const c2 = JSON.parse(JSON.stringify(o));
console.log(c1 === c2);
console.log(c1.x === c2.x);
//JSON은 객체를 모두 string으로 바꿈
//parse는 JSON의string문자들을 다시 객체로 반환하는 역할
//복사가 아닌 JSON을 통해 똑같이 만드는 것일 뿐임으로 
// 값과 메모리 상태가 다르다.

// lodash의 cloneDeep을 사용한 깊은 복사
const _ = require('lodash');
// require은 lodash"모듈"을 가져오는 역할
// 깊은 복사
const c3 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
```
**결국 원시값은 값이 같아야하고 객체는 참조가 같아야 한다.**
```javascript
var person = { name: 'Lee' };
// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```
```javascript
// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
changeVal(num, person);

// 원시값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```
* 객체는 참조값을 넘기기에 다른 메서드나 객체에 의해 값 변경이 이루어 질 수있다.
* 원시값은 값복사만 일어나기에 원형을 유지한다. 

### 함수
**★★★함수 리터럴 표현식**
```javascript
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
* var f 선언이 붙고 ;로 객체로 취급한다
* add호출이 불가하고 add함수를 f로 선언하기로 약속한것이다.

**★★★그룹연산자사용으로 즉시함수식으로 변형**
```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // 함수문

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); })(); // 즉시실행 함수식
bar(); // ReferenceError: bar is not defined
```
* ()붙이면 식이 되고 없에면 문이 된다.
* 즉시 함수식은 1회성이므로 호출 불가하다.
**함수 생성자 함수**
```javascript
var add = new Function('x', 'y', 'console.log(x,y), return x + y');

console.log(add(2, 5)); // 7
```
**화살표 함수**
```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
**★★★scope!! outer와 inner 함수**
```javascript
function outer() {
  var x = 1;
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); 
    // x는 아우터의 지역변수, y는 inner의 지역변수
  } inner(); }
outer();
```
**시험!★★★callback 함수**
* 클라이언트가 기능을 서비스 코드에 삽입 가능하게하는 함수.
* 클라이언트가 가진 정책을 서비스코드에 반영 
```javascript
//Server Code
function repeat(n, f) { 
  for (var i = 0; i < n; i++) {
    f(i);  // callback
  }
}
//Client Code
var logAll = function (i) { //callback function구현
  console.log(i);
};
repeat(5, logAll); //callback function구현
repeat(5, (n) => console.log('--' + n + '--')); //callback function구현
repeat(5, function(a){console.log(a,a,a);}); //callback function구현
```
* 콜백 함수를 사용한 이벤트 처리
```javascript
document.getElementById('myButton').addEventListener('click', function () {
  console.log('button clicked!');
});

// 콜백 함수를 사용한 비동기 처리
setTimeout(function () {
  console.log('1초 경과');
}, 1000);
```
* 고차함수 3가지
```javascript
var res = [1, 2, 3].map(function (item) {
  return item * 2; });
console.log(res); // [2, 4, 6]

res = [1, 2, 3].filter(function (item) {
  return item % 2; });
console.log(res); // [1, 3]

res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur; }, 0);
console.log(res); // 6
```
* map과 filter는 배열 생성 reduce는 단 1개의 값만 생성 

* 순수 함수
```javascript
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.
// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}
// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1
```
* 비순수 함수
```javascript
var count = 0; 
// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}
// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1
```


### Scope
* Scope란 우리말로 '범위' 변수에 접근 할 수있는 유효범위라고 한다.
* 자스 스코프는 2가지 타입이 있다 바로 global(전역)과 local(지역)

```javascript
var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수

if (true) {
  var var2 = 2; // 코드 블록 내에서 선언한 변수
  if (true) {
    var var3 = 3; // 중첩된 코드 블록 내에서 선언한 변수
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언한 변수

  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언한 변수
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```
* 전역 변수로써 var는 활용되지만 함수안에서는 함수로써 변수로만 활동한다.
* 함수범위로써의 변수라고 한다. 함수이외는 전부 전역 변수 if else등 무시.

* const 확실히 사용에 대문자를 이용해 표현 
```javascript
const Tax = 0.1;
```
**중요!!!!!**
* 일반 cosnt는 값 변경이 불가능하다.
* 그러나 const 참조 객체는 참조값의 값 변경이 가능하다!
```javascript
const person = {
  name: 'Lee'
};

// 객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.
person.name = 'Kim';

console.log(person); // {name: "Kim"}
```
### 객체의 속성 
* 객체에는 여러 속성을 가질 수 있음 함수, 값 등
```javascript
/ 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
person.sayHello = function () {
  console.log('Hi! My name is ' + this.name); 
};
console.log(person); // {name: "Lee", sayHello: ƒ}
person.sayHello(); // Hi! My name is Lee
```
**프로토 타입 객체!! 시험**
* 자바스크립트 자체 내부에서 사용하는 엔진 구조
 - 내부 슬롯
  + 프로퍼티
  + 메소드
```javascript
const o = {};

// 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다.
o.[[Prototype]] // -> Uncaught SyntaxError: Unexpected token '['
// 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.
o.__proto__ // -> Object.prototype
```
* 모든 객체는 Prototpye이라는 요소를 가진다. [[Prototype]]
  - __proto__  [[Prototype]]의 접근자속성라고하고 이렇게 사용한다.
  - __proto__ 객체는 또한 getter, setter 라는 access속성을 가짐
```javascript
const person = {
  name: 'Lee'
};
person.age = 20;
console.log(Object.getOwnPropertyDescriptor(person));
// Object는 생성자의 메서드!! 
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
// 중요한 점은 이 메서드는 단 1개만 존재하는 클래스로써 여러 사용이 불가함.
```
![prototype1](https://user-images.githubusercontent.com/56966606/162617815-1dd6b541-1604-49e3-befb-3fb267497a1b.png)
* 모든 생성자함수만이 prototype속성을 가지고 있다.
* 생성자 함수가 가진 prototype 속성을 이용하여 최상위 부모객체가 존재하게 된다.
* 최상위 부모객체(object.prototype)는 Prototype속성을 가지지 않는다.
* 생성자 함수와 다른 객체요소는 이 프로토타입에 의존한다.
* 생성자 함수&부모객체를 제외한 의존 객체는 모두 prototype을 가진다.
* 프로토타입에 의해 만들어진 객체는 __p__로 참조가능하다.
```javascript
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 인스턴스의 생성
const circle1 = new Circle(5);  // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```




```javascript
function Circle(radius) {
  // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.

  // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };

  // 3. 암묵적으로 this를 반환한다.
  // 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.
  return 100;
}

// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.
const circle = new Circle(1);
console.log(circle); // Circle {radius: 1, getDiameter: ƒ}
```


```javascript
function foo() {}

// 일반적인 함수로서 호출: [[Call]]이 호출된다.
foo();

// 생성자 함수로서 호출: [[Construct]]가 호출된다.
new foo();
```

```javascript
// 일반 함수 정의: 함수 선언문, 함수 표현식
function foo() {}
const bar = function () {};
// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.
const baz = {
  x: function () {}
};

// 일반 함수로 정의된 함수만이 constructor이다.
new foo();   // -> foo {}
new bar();   // -> bar {}
new baz.x(); // -> x {}

// 화살표 함수 정의
const arrow = () => {};

new arrow(); // TypeError: arrow is not a constructor

// 메서드 정의: ES6의 메서드 축약 표현만을 메서드로 인정한다.
const obj = {
  x() {}
};

new obj.x(); // TypeError: obj.x is not a constructor
```

* console.dir 
 + 단 1개의 객채만을 출력하기 위한 코드
```javascript
function square(number) {
  return number * number;
}
console.dir(square);
// 객체 정보를 출력한다.
```
**객체 Object의 프로토타입**
```javascript
function square(number) {
  return number * number;
}

console.log(Object.getOwnPropertyDescriptors(square));
/*
{
  length: {value: 1, writable: false, enumerable: false, configurable: true},
  name: {value: "square", writable: false, enumerable: false, configurable: true},
  arguments: {value: null, writable: false, enumerable: false, configurable: false},
  caller: {value: null, writable: false, enumerable: false, configurable: false},
  prototype: {value: {...}, writable: true, enumerable: false, configurable: false}
}
*/

// __proto__는 square 함수의 프로퍼티가 아니다.
console.log(Object.getOwnPropertyDescriptor(square, '__proto__')); // undefined

// __proto__는 Object.prototype 객체의 접근자 프로퍼티다.
// square 함수는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}
```

* 유사배열& iterator
 + 자바스크립트는 여러개의 개체를 참조 할수있다.
 + 유사배열 객체는 length프로퍼티와 []연산자등 배열관련 요소를 가지고있다.
 + 객체.[Symbol.iterator]();라고 이터러블 선언을 할 수 있다.
* 배열 객체
```javascript
unction sum() {
  // arguments 객체를 배열로 변환
  const array = Array.prototype.slice.call(arguments);
  return array.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}
console.log(sum(1, 2));          // 3
console.log(sum(1, 2, 3, 4, 5)); // 15
```
* 중요한 점은 Array생성자 함수 의 프로토타입의 slice기능을 사용 할 수있다는 것.
* 자스는 논리적으로 slice기능을 자삭객체가 자기것인 것처럼 쓸 수 있다.

**객체 프로토타입 프로퍼티 확인**
```javascript
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log(obj.__proto__ === Object.prototype); // true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다.
console.log(obj.hasOwnProperty('a'));         // true
console.log(obj.hasOwnProperty('__proto__')); // false
```

```javascript
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```
()소괄호
{}중괄호
[]대괄호
객체 접근방법
```javascript
var a = { name : 'hong', age : 30 };
a.name;
a["name"];
```
* 객체와 함수
* 객체생성 방법
  + 생성자 함수
  ```javascript
  var a = new object();
  console.log(o1.__proto__);  // [Object: null prototype] {}
  console.log(Object.prototype);  // [Object: null prototype] {}
  console.log(o1.__proto__.__proto__);    // null
  console.log(Object.prototype.__proto__);    // null
  ```
  + 리터럴 객체
  ```javascript
  var a = { };
  ```
```javascript
const Person = (function(){
    function Person(n, a){
        this.name = n;
        this.age = a;
    }
    Person.prototype.toString = function ()
    {
        // 프로토타입 메서드 재정의
        return `name: ${this.name}, age: ${this.age}`;
        // 메서드 쉐도잉& 오버라이딩
        // Person 프로토타입에 직접 재정의
    }
    Person.print = function(){ console.log("생성자 함수 Person"); }
    // 생성자 함수의 메서드이며 객체에 상속되는 메서드는 아니다.

    return Person;
}());
// 변수와 함수를 같이 세트로 활용하기에 위해 즉시실행함수로 묶는다.
let p1 = new Person('hong', 25);
let p2 = new Person('lee', 30);
console.log(p1.toString());
console.log(p2.toString());
Person.print();
```
**이를 바탕으로 프로토타입 체인 만들기 시험!**
![proto](https://user-images.githubusercontent.com/56966606/165665871-e2c31e9d-65ee-4ac2-95a7-e05c6d9e92e2.png)
```javascript
const Person = (function(){
    function Person(n, a){
        this.name = n;
        this.age = a;
    }
    Person.prototype.toString = function ()
    {
        return `name: ${this.name}, age: ${this.age}`;
    }
    Person.print = function(){ console.log("생성자 함수 Person"); }
    return Person;
}());
// 프로토타입 바꿔보기
let proto = {
    constructor : Person,
    toString : function(){
        console.log("prototype toString()");
    } ,
    getName : function(){
        return this.name;
    } ,
    getAge : function(){
        return this.age;
    }
}
Person.prototype = proto;
let p1 = new Person('hong', 25);
console.log(p1.toString());
console.log(p1.getName);
console.log(p1.getAge);
```
# 기말 2차시
## **엄격모드 'use strict'**
 ```javascript
 // 키워드 없이 문법 선언 못하도록 하는 'use strict';
 (function foo(){
  'use strict';
  x = 10; // 'use strict' 때문에 출력 에러가 발생한다.
})();
 ```
* 'use strict'를 통해 함수 내에서만 사용가능하다.
* let, var, const 없이 만들면 전역 변수 취급이된다.
* 'use strict'는 매개 변수 중복 사용 불가능
```javascript
(function () {
  'use strict';
  //SyntaxError: Duplicate parameter name not allowed in this context
  function foo(x, x) { return x + x; }
  console.log(foo(1, 2));
}());
```
* with 사용불가
**'use strict에서 'this의 동작방식**
```javascript
function foo(){
    console.log(this); // undefined    
}
```
* 전역함수에서 'use strict'일때 this는 undefined값을 가진다.
* 'use strict'전역함수에서 this는 전역객체로써 동작한다.
**html에서의 엄격모드**
```html
<!DOCTYPE html>
<html>
<body>
  <script>'use strict';</script>
  
  <script>
    // 스크립트 내 엄격모드 코드가 없어서 잘 작동한다.
    x = 1; // 에러가 발생하지 않는다.
    console.log(x); // 1
  </script>
  
  <script>
    'use strict';
    y = 1; // ReferenceError: y is not defined
    console.log(y);
  </script>
  
</body>
</html>
```
**변경된 인수가 arguments 객체에 반영되지 않는다.**
```javascript
(function (a) {
  'use strict';
  // 매개변수에 전달된 인수를 재할당하여 변경
  a = 2;

  // 변경된 인수가 arguments 객체에 반영되지 않는다.
  console.log(arguments); // { 0: 1, length: 1 }
}(1));
```

**built in 객체**
```javascript
const uri  = 'http://example.com?name=이웅모&job=programmer&teacher'; 
let enc = encodeURIComponent(uri); // 한글 같은 요소를 바꿔준다.
console.log(enc);
// 글로벌 서버를 사용하기 위해서 주소로 url은 표준 주소로 바꿔줘야한다.
// 지역적 특성을 가진 요소를 넣으면 안된다,
let dec = decodeURIComponent(uri);
console.log(dec);
```

## **중요!!! 파트 this**
```javascript
const circle = {
    radius : 5,
    getDiameter(){ return 2 * circle.radius; }
};
// new와 함게 생성된 참조 식별자(만들어진 자기 자신)를 this라고 한다.
```
* 리터럴 객체 내 this는 리터럴 자체이다.
```javascript
circle.prototype.getDiameter = function(){
    return 2 * this.radius;
}
```
* 프로토타입선언 객체에서의 this는 이 함수를 호출한 객체가 this가 된다.
**함수 호출 방식 4가지에서의 this**
1. 일반 함수 호출
```javascript
//this는 전역 객체 window를 가르킨다.
const foo = function(){
    console.dir(this);
}
```
2. 메서드 호출
```javascript
const foo = function(){
    console.dir(this);
}
//foo는 함수 내부의 this는 메서드를 호출한 객체 obj를 가르킨다.
const obj = { foo : foo };
obj.foo();
```
3. 생성자 함수 호출
```javascript
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 반지름이 5인 Circle 객체를 생성
const circle1 = new Circle(5); // new를 통한 생성자 함수 호출!
// 반지름이 10인 Circle 객체를 생성
const circle2 = new Circle(10); // new를 통한 생성자 함수 호출!

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```
**4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출 시험!!!**
```javascript
//foo 함수 내부의 this는 인수에 의해 결정된다.
const foo = function(){
  console.dir(this);
}
const bar = { name : 'bar' };
foo.call(bar, 1, 2, 3); //this를 리스트를 내가 원하는 인수로 결정해서 함수호출
//bar.foo(1, 2, 3);랑 똑같음
foo.apply(bar, [1, 2, 3]); //this를 배열로 내가 원하는 인수로 결정해서 함수호출
//bar.foo([1, 2, 3]);랑 똑같음
foo.bind(bar)(1, 2, 3); //this를 바인딩한 함수를 반환한다.
//bar.foo();
```
**리터럴 내 전역 메서드는 일반 메서드 형식으로 판단된다.**
```javascript
// var 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티다.
var value = 1;
// const 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티가 아니다.
// const value = 1;

const obj = {
  value: 100,
  foo() {
    console.log("foo's this: ", this);  // {value: 100, foo: ƒ}
    console.log("foo's this.value: ", this.value); // 100

    // 메서드 내에서 정의한 중첩 함수
    function bar() {
      console.log("bar's this: ", this); // window
      console.log("bar's this.value: ", this.value); // 1
    }

    // 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.
    bar();
  }
};
**콜백 함수는 일반함수**
```javascript
var value = 1;

const obj = {
  value: 100,
  foo() {
    console.log("foo's this: ", this); // {value: 100, foo: ƒ}
    // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.
    setTimeout(function () {
      console.log("callback's this: ", this); // window
      console.log("callback's this.value: ", this.value); // 1
    }, 100);
  }
};

obj.foo();
```
**배열이 아닌것들을 배열 객체로 반환하는 방법**
```javascript
function convertArgsToArray(){
    console.log(arguments); // arguments 유사 배열
    // const arr = Array.prototype,slice.call(arguments);
    // 객체는 프로토타입의 상속 되있기에 프토토타입 안에 정의된 slice함수도 사용가능하다.
    console.log(arr);
    const arr = Array.prototype.slice.call(arguments);
    console.log(arr);
    return arr;
}
//=====================================================================
const a = [1,2,3];
const b = a.slice(1, 3); // 1포함한 3이하의 숫자까지 배열을 자르겠다. 
// == const b = Array.prototype.slice.apply(a,[1,3]);
console.log(a);
console.log(b); //[ 1, 2 ]
```
* argument를 통한 유사배열로 바꾸기
* Array의 함수 사용해서 바꾸기
**this를 person 객체로 바꿔보기**
```javascript
const person = {
  name: 'Lee',
  foo(callback) {
    // ①
    setTimeout(callback, 100);
  }
};
person.foo(function () {
  console.log(`Hi! my name is ${this.name}.`); // ② Hi! my name is .
  // 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.
  // 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.
  // Node.js 환경에서 this.name은 undefined다.
});
```

## **closure 중요!!**
* 함수가 꼭 있어야하며 외부변수 참조를 가지는 상태여야 한다.
* 함수가 외부변수를 참조할때 리턴 되지않고 남아있는 상태.
**자스가 코드 참조하는 순서 **
```javascript
const x = 1; // 3

function outerFunc() { // 2
    const x = 10;
    innerFunc();
}
function innerFunc(){ // 1
    console.log(x); 
}
outerFunc();
```
1. inner
2. outer
3. 전역
4. 마지막은 undefined

****
```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 클로저
      // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
      function bar() {
        debugger;
        // Debugger는 소스코드 중간에 웹에서 디버거에서 멈추게 할수 있다.(일시정지)
        console.log(x); 
        // console.log(x)에서 x를 참조하고 있다.
        // 때문에 함수를 실행해도 x값은 리턴되고나서 없어지지않고 메모리상 남아있으며 클로저가 실행된다.
      }
      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```
* 디버거로 먼춰두면 x를 계속 참조하는 상태가 되어서 클로서를 확인할 수 있다.
* 원래 클로서는 일반 컴팡일링에서 확인 불가하다.
```javascript
const increase = (function(){
    let num = 0;
    //클로저
    let bar = function(){
        return ++num;
    };
    return bar;
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```
![Person_prototype](https://user-images.githubusercontent.com/56966606/169195039-ac9e22dd-f69c-4831-9b57-6a1421b98d2b.png)
![Animal_prototype](https://user-images.githubusercontent.com/56966606/169195047-1088b747-4c25-4f0f-bc9c-cb0d0e8a58ba.png)
// function Person(name, age){
//     this.name = name; 
//     let_age = age; //내부생성된 클로저

//     this.sayHi = function(){
//         console.log(`Hi! My name is${this.name}, age is${_age}`);
//     }
//
//     Person.prototye
// };


// 생성자 패턴 24-19
// 외부 데이터 멤버와 프로토타입 함수를 가지는 객체
// const Person = (function{
//     let_age = 0;

//     //생성자 함수
//     function Person(name, age){
//         this.name = name;
//         _age = age; //클로저 외부 참조 불가
//     }
//     //prototype
// });

// var의 전역변수
// 최종적으로 3값을 가진다.
// var funcs = [];
// for(var i = 0; i < 3; i++){
//     funcs[i] = function() {return i;};
// }
// for(var j = 0; j < funcs.length; j++){
//     console.log(funcs[j]());
// }
//이걸 고치려면 var 사용을 지양해야한다.


//# 클래스
// 기존의 생성자 함수로 객체생성 방법
// (function Perosn(name){
//     this.name = name;
   
//     Perosn.prototype.sayHi = function(){
//         console.log("Hi my name is " + this.name);
//     }
// })();
// const o1 = new Person("lee");
// const o2 = new Person("park");

// console.log(o1, o2);

//클래스 표현식
//class Person {}

//시험
//클래스에서 constructor는 무조건 써야한다
//constructor는 생성자의 역할을 한다
//클래스안에 메서드로 인식된다
//sayHi 프로토타입 메서드등등
class Perosn {
    constructor(name){ //생성자
        this.name = name;
    }
    sayHi(){
        console.log(`Hi! My name is ${this.name}`);
    }
    static sayHello(){ //생성자가 가진 sayhello
        console.log("Hello");
    }
}
//const p1 = new Person("Lee");
/*
클래스는 생성자, 메서드, 정적 메서드 3가지밖에 안가지고 있다.
클래스는 인스턴스 생성시 new를 무조건 사용해야한다.
25-11 생성자와 변수 선언
constructor는 정수 반환이 안된다.
25-24 시험 prototype 확인
25-31 5개의 생성자의 정적메서드 알아두기 
25-32 생성자 작동 순서
25-35 시험 클래스와 리터럴 객체의 차이
*/
class PErson{
    name = "lee";

    // constructor(){
    //     this.name = "Lee";
    // }
}
// 두개는 똑같은 방식의 생성자 이다.
// 중요 25-46 클래스내에 getName은 함수 프로퍼티이지 메서드가 아니다.
/*getName = function(){}은 일반 함수, getName(){}은 메서드이며 프로토타입에서 생성이 된다.*/
// 중요 25-47 doom과 이벤트 핸들러 increase의 this는 app객체를 가르킨다.
// 상속 25-54 자식은 생서자로 만들어져 constructor가 없기에 부모인 animal의 constructor를 호출한다.
// 25-60 자식 클래스입장에서 ...arg 배열로 매개변수를 받는 rest 파라미터 , super(...arg)은 스프레드 문법 부모거를 가져온다.
// 25-64 암기 기본적인거임 ㅇㅇ 
// 25-65 자식이 부모 거를 가져와야해서 super를 통해서 무조건 먼저 가져와야한다.
// 25-68 자식이 상속 받은 것을 명시적으로 표현하는 법 안하면 재귀함가 되어버림
// 25-80 배열 만드는 법 reduce, filter 통해 배열 연산
// 25-82 자식인 myArray를 호출한다.
// 25-83 static get [Symbol.species]() {return Array;}로 부모타입을 반환 할 수있게한다

// 26-04
// function server( f ){
//     console.log('server()');
//     f();// 콜백
//     console.log('server()');
// }
// function client(){// 콜백함수
//     console.log("client()");
// }
// server( client );
// // map함수를 통한 콜백함수 구현
// function m(item) {
//     return item + 10;
// }
// console.log([1,2,3].map(m));
//26-14
// const arrow = (x, y) => {   
// console.log(x, y);
// }
// console.log(arrow(1, 2));
//26-18 람다식
//26-21
//화살표함수는 생성자가 없음 고로 프로토타입도 없음
//26-34this는 a:1로 정하게하는 방법 call 
//매우엄청중요! 26-44
class Person{
    name = "Lee";
    sayHi = () => console.log(`Hi ${this.name}`);
}
//sayHi는 메서드아니고 this는 누구거인지 물어보는 문제
