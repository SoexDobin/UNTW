
* 자바스크립트가 하는 일
  - html, css 추가 삭제 변경
  - 원격 서버 요청
  - 사용자 이벤트 반응
  - 브라우저 안에서 데이터 읽고 쓰기
  + Node.exe 자바스크립트로 외부에서 작용

* 변수 선언 방식
  - var 
  - let (변수 정리)
  - const (상수 정리)

**암기하기★**
* 데이터 내장 타입 (단일 값)
  - 숫자타입 number
  - 문자열타입 string
  - 불린 boolen
  - undefined (초기화X)
  - null (값이 없다, 참조 제거)
  - symbol (유니크한 어떤 private값 == key)
  - bigint(컴퓨터가 인식하는 이상의 숫자)
* 객체 타입 (다양한 값)
  - object
**암기하기★**
* 정적 타입
  - 무조건 같은 타입만을 받음
  - char, string
* 동적 타입
  - ★동적 타입을 참조 형식으로 값을 할당함
  - 변수를 보고 타입을 판단 함
  - 가비지 컬렉터가 버려진 참조 형태의 변수를 알아서 제거해줌 
  - let, const, var

* 문 statement
  - ~문과 표현식으로 이루어짐
  - 초기화가 되는 변수가 있는 문은 표현식
  - 단지 아무것도 받지않고 선언만하면 문이라함 ex.함수문 var문

 * 형변환 
 ``` javascript
console.log("" + 1 + 0);    // "10"
console.log("" - 1 + 0);    // -1
console.log(true + false);  // 1
console.log(6 / "3");       // 2
console.log("2" * "3");     // 6
console.log(4 + 5 + "px");  // "9px"
console.log("$" + 4 + 5);   // $45
console.log("4" - 2);       // 2
console.log("4px" - 2);     // NaN★★★
console.log(7 / 0);         // Infinity★★★
console.log("  -9  " + 5);  // "  -9  5"
console.log("  -9  " - 5);  // -14
console.log(null + 1);      // 1
console.log(undefined + 1); // NaN
console.log(" \t \n" - 2);  // -2

let n = 10;
console.log(+n);            // 10
console.log(-n);            // -10
console.log(+Infinity);     // Infinity
console.log(-Infinity);     // -Infinity
console.log(+"10" + 1);     // 11★★★
console.log("10" * 1 + 1);  // 11★★★
 ```

 * 비교연산자
  - ++a 문장을 실행하며 증가 a++ 문장이 끝나고 난후 증가
  - == 값이 같은가?
  - === 값과 타입이 같은가?

* 3항 연산식
```javascript
var x = 2;

// 0은 false로 취급된다.
var result = x % 2 ? '홀수' : '짝수';
```
```javascript
var num = 2;

// 0은 false로 취급된다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';

console.log(kind); // 양수
```

* switch문
```javascript
// 월을 영어로 변환한다. (11 → 'November')
var month = 11;
var monthName;

switch (month) {
  case 1: monthName = 'January'; break;
  case 2: monthName = 'February'; break;
  case 3: monthName = 'March'; break;
  case 4: monthName = 'April'; break;
  case 5: monthName = 'May'; break;
  case 6: monthName = 'June'; break;
  case 7: monthName = 'July'; break;
  case 8: monthName = 'August'; break;
  case 9: monthName = 'September'; break;
  case 10: monthName = 'October'; break;
  case 11: monthName = 'November'; break;
  case 12: monthName = 'December'; break;
  default: monthName = 'Invalid month';
  case a: case: b case: c days = 30; break; //중복도 가능
}
console.log(monthName); // November
```
* for문
```javascript
// 무한루프
for (;;) { ... }

//중첩 for문
for (var i = 1; i <= 6; i++) {
  for (var j = 1; j <= 6; j++) {
    if (i + j === 6) console.log(`[${i}, ${j}]`);
  }
}
```

while문
```javascript
// 무한루프
while (true) {
  console.log(count);
  count++;
  if (count === 3) break; 
  // 타입과 값이 같으면
}

var count = 0;

// do while문 값이 false여도 무조건 1번 실행됨
// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
// false 값이더라도 1번은 돌아감
var count = 10;
do {
  console.log(count);
  count++;
} while (count < 3);
//
```
foo레이블 식별자
```javascript
// foo라는 식별자가 붙은 레이블 블록문
foo: {
  console.log(1);
  break foo; // foo 레이블 블록문을 탈출한다.
  console.log(2); //실행 안됨!
}
```
foo를 outer라고 쓴것 뿐임 위에랑 같은 방식 탈출코드
```javascript
// outer라는 식별자가 붙은 레이블 for 문
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.
    if (i + j === 3) break outer;
    console.log(`inner [${i}, ${j}]`);
  }
}

console.log('Done!');
```
```javascript
var string = 'Hello World.';
var search = 'l';
var index;

// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.
for (var i = 0; i < string.length; i++) {
  // 문자열의 개별 문자가 'l'이면
  if (string[i] === search) {
    index = i;
    break; // 반복문을 탈출한다.
  }
}
console.log(index); // 2
//================================================================
// 참고로 String.prototype.indexOf 메서드를 사용해도 같은 동작을 한다.
console.log(string.indexOf(search)); // 2
```
console.log(String(string).indexOf(search)); 부모가 만들어놓은 객체
를 우리는 console.log(string.indexOf(search)); 이렇게 써서 불러오고
indexof메소드를 사용하게 된다.
**(.)연산자를 통한 멤버접근 래퍼객체**★★★

**String 생성자 함수 ★★**
```javascript
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
// 숫자 타입 => 문자열 타입
String(1);        // -> "1"
String(NaN);      // -> "NaN"
String(Infinity); // -> "Infinity"
// 불리언 타입 => 문자열 타입
String(true);     // -> "true"
String(false);    // -> "false"

// 2. Object.prototype.toString 메서드를 사용하는 방법
// 숫자 타입 => 문자열 타입
(1).toString();        // -> "1"
(NaN).toString();      // -> "NaN"
(Infinity).toString(); // -> "Infinity"
// 불리언 타입 => 문자열 타입
(true).toString();     // -> "true"
(false).toString();    // -> "false"

// 3. 문자열 연결 연산자를 이용하는 방법
// 숫자 타입 => 문자열 타입
1 + '';        // -> "1"
NaN + '';      // -> "NaN"
Infinity + ''; // -> "Infinity"
// 불리언 타입 => 문자열 타입
true + '';     // -> "true"
false + '';    // -> "false"
```
**Number 생성자 함수 ★★**
```javascript
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0');     // -> 0
Number('-1');    // -> -1
Number('10.53'); // -> 10.53
// 불리언 타입 => 숫자 타입
Number(true);    // -> 1
Number(false);   // -> 0

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
// 문자열 타입 => 숫자 타입
parseInt('0');       // -> 0 ★★
parseInt('-1');      // -> -1 ★★
parseFloat('10.53'); // -> 10.53 ★★

// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
+'0';     // -> 0
+'-1';    // -> -1
+'10.53'; // -> 10.53
// 불리언 타입 => 숫자 타입
+true;    // -> 1
+false;   // -> 0

// 4. * 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
'0' * 1;     // -> 0
'-1' * 1;    // -> -1
'10.53' * 1; // -> 10.53
// 불리언 타입 => 숫자 타입
true * 1;    // -> 1
false * 1;   // -> 0
```

**논리연산자★★★★★**
&& 단축평가
And연산자는 앞이false면 뒤를 확인 안함
|| 단락평가
or연산자는 앞이true면 뒤를 확인 안함
```javascript
"Cat" && "Dog" //-> "Dog"
"Cat" || "Dog" //-> "Cat"
```
**null통한 동적메모리 확인★★★**
```javascript
var elem = null;
// elem이 null이나 undefined와 같은 Falsy 값이면 elem으로 평가되고
// elem이 Truthy 값이면 elem.value로 평가된다.
var value = elem && elem.value; // -> null
//===================================================================
var elem = null;

// elem이 null 또는 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
var value = elem?.value;
console.log(value); // undefined
//===================================================================
// 좌항의 피연산자가 null 또는 undefined이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
var foo = null ?? 'default string';
console.log(foo); // "default string"
```
## 객체생성방법
  - 객체 리터럴
  - object생성자 함수
  - object.create()메서드
  - 사용자 생성자 함수
  - 클래스 사용하는 방법

**객체 리터럴**
```javascript
var person = {
  name: 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  }
};

console.log(typeof person); // object
console.log(person); // {name: "Lee", sayHello: ƒ}
//{ property key : property value }로 쓰면됨
// {} 리터럴 객체라고 함
// 함수를 객체로 가지게 되면 메서드라고 부름
```
* delete 소멸자
```javascript
var person = {
  name: 'Lee'
};

// 프로퍼티 동적 생성
person.age = 20;

// person 객체에 age 프로퍼티가 존재한다.
// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있다.
delete person.age;

// person 객체에 address 프로퍼티가 존재하지 않는다.
// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.
delete person.address;

console.log(person); // {name: "Lee"}
```

* **시험★★★★★**
```javascript
// ES5
var x = 1, y = 2; // value 부분
 
var obj1 = { x: x, y: y }; //key부분
var obj2 = { x, y };

console.log(obj1); // {x: 1, y: 2}
console.log(obj2); // {x: 1, y: 2} 익스6이상부터 지원
//key와 value가 같으면 생략을 통해 사용가능
```
* 템플릿 문자열
```javascript
const prefix = 'prop';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i };

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 원시값과 객체의 비교
**시험★★★★★**
![원시 변수 값변경](https://user-images.githubusercontent.com/56966606/161897422-c31cb3d7-42a6-4ba0-8a56-76f14f2b737d.png)
* 변수 값 변경은 값이 갈아치워지는게 아닌 다른메모리에 할당된 변수로 주소가 참조 되는 것이다.

![shallow deep copy](https://user-images.githubusercontent.com/56966606/161899008-c31ebbe5-da53-403d-b2f4-0b8ced601b81.png)
**시험★★★★★**
```javascript
const o = { x: { y: 1 } }; // 2번에 걸쳐 옅은복사 참조

// 얕은 복사
const c1 = { ...o }; // 35장 "스프레드 문법" 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

const c2 = JSON.parse(JSON.stringify(o));
console.log(c1 === c2);
console.log(c1.x === c2.x);
//JSON은 객체를 모두 string으로 바꿈
//parse는 JSON의string문자들을 다시 객체로 반환하는 역할
//복사가 아닌 JSON을 통해 똑같이 만드는 것일 뿐임으로 
// 값과 메모리 상태가 다르다.

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');
// require은 lodash"모듈"을 가져오는 역할
// 깊은 복사
const c3 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```
**결국 기본타입값이 같아야하고 객체는 참조가 같아야 한다.**
```javascript
var person = { name: 'Lee' };
// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

### 함수
**★★★함수 리터럴 표현식**
```javascript
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
* var f 선언이 붙고 ;로 객체로 취급한다
* add호출이 불가하고 add함수를 f로 선언하기로 약속한것이다.

**★★★그룹연산자사용으로 즉시함수식으로 변형**
```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); })(); //즉시 실행 함수
bar(); // ReferenceError: bar is not defined
```
**생성자 함수**
```javascript
var add = new Function('x', 'y', 'console.log(x,y), return x + y');

console.log(add(2, 5)); // 7
```
**화살표 함수**
```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
**★★★scope!! outer와 inner 함수**
```javascript
function outer() {
  var x = 1;
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); 
    // x는 아우터의 지역변수, y는 inner의 지역변수
  } inner(); }
outer();
```
**시험!★★★callback 함수**
* 클라이언트가 기능을 서비스 코드에 삽입 가능하게하는 함수.
```javascript
//Server Code
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); } } // i를 전달하면서 f를 호출
//Client Code
var logAll = function (i) {
  console.log(i);
};
repeat(5, logAll); //callback function구현
repeat(5, (n) -> console.log("+n"));
repeat(5, function(n){console.log(n,n,n);});
```
* 콜백 함수를 사용한 이벤트 처리
```javascript
document.getElementById('myButton').addEventListener('click', function () {
  console.log('button clicked!');
});

// 콜백 함수를 사용한 비동기 처리
setTimeout(function () {
  console.log('1초 경과');
}, 1000);
```
* 고차함수 3가지
```javascript
var res = [1, 2, 3].map(function (item) {
  return item * 2; });
console.log(res); // [2, 4, 6]

res = [1, 2, 3].filter(function (item) {
  return item % 2; });
console.log(res); // [1, 3]

res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur; }, 0);
console.log(res); // 6
```
* map과 filter는 배열 생성 reduce는 단 1개의 값만 생성   
* 순수 함수
```javascript
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.
// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}
// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1
```
* 비순수 함수
```javascript
var count = 0; 
// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}
// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1
```
### Scope
* Scope란 우리말로 '범위' 변수에 접근 할 수있는 범위라고 한다.
* 자스 스코프는 2가지 타입이 있다 바로 global(전역)과 local(지역)
