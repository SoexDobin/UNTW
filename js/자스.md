!데이터타입
!정적타입, 동적타입 (비교연산자)
! String, Number 생성자 함수
!!논리연산자, 단축평가
!! null 동적 메모리 확인
!!객체리터럴 - value, key value같으면 생략가능
!! 원시값과 객체비교
!! shallow deep copy
!!함수 리터럴 표현식
!!그룹연산자 함수리터럴
!생성자, 화살표 함수
!! 중첩함수 
!!callback함수 - 서비스, 클라 구별, 콜백 기능 구별
!스코프 -  원시값의 스코프 범위 함수레벨 스코프 범위
!!생성자함수 - new로 생성자 호출할때와 그냥 호출시 차이점 return
!!모든 객체의 최상위 프로토타입 객체는 object.prototype이다.
+ 프로토타입 상속 구성



* 자바스크립트가 하는 일
  - html, css 추가 삭제 변경
  - 원격 서버 요청
  - 사용자 이벤트 반응
  - 브라우저 안에서 데이터 읽고 쓰기
  + Node.exe 자바스크립트로 외부에서 작용

* 변수 선언 방식
  - var 
  - let (변수 정리)
  - const (상수 정리)

**암기하기★**
* 데이터 내장 타입 (단일 값)
  - 숫자타입 number
  - 문자열타입 string
  - 불린 boolen
  - undefined (초기화X)
  - null (값이 없다, 참조 제거)
  - symbol (유니크한 어떤 private값 == key)
  - bigint(컴퓨터가 인식하는 이상의 숫자)
* 객체 타입 (다양한 값)
  - object
**암기하기★**
* 정적 타입
  - 무조건 같은 타입만을 받음
  - char, string
* 동적 타입
  - ★동적 타입을 참조 형식으로 값을 할당함
  - 변수를 보고 타입을 판단 함
  - 가비지 컬렉터가 버려진 참조 형태의 변수를 알아서 제거해줌 
  - let, const, var

* 문 statement
  - ~문과 표현식으로 이루어짐
  - 초기화가 되는 변수가 있는 문은 표현식
  - 단지 아무것도 받지않고 선언만하면 문이라함 ex.함수문 var문

 * 형변환 
 ``` javascript
console.log("" + 1 + 0);    // "10"
console.log("" - 1 + 0);    // -1
console.log(true + false);  // 1
console.log(6 / "3");       // 2
console.log("2" * "3");     // 6
console.log(4 + 5 + "px");  // "9px"
console.log("$" + 4 + 5);   // $45
console.log("4" - 2);       // 2
console.log("4px" - 2);     // NaN★★★
console.log(7 / 0);         // Infinity★★★
console.log("  -9  " + 5);  // "  -9  5"
console.log("  -9  " - 5);  // -14
console.log(null + 1);      // 1
console.log(undefined + 1); // NaN
console.log(" \t \n" - 2);  // -2

let n = 10;
console.log(+n);            // 10
console.log(-n);            // -10
console.log(+Infinity);     // Infinity
console.log(-Infinity);     // -Infinity
console.log(+"10" + 1);     // 11★★★
console.log("10" * 1 + 1);  // 11★★★
 ```

 * 비교연산자
  - ++a 문장을 실행하며 증가 a++ 문장이 끝나고 난후 증가
  - == 값이 같은가?
  - === 값과 타입이 같은가?

* 3항 연산식
```javascript
var x = 2;

// 0은 false로 취급된다.
var result = x % 2 ? '홀수' : '짝수';
```
```javascript
var num = 2;

// 0은 false로 취급된다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';

console.log(kind); // 양수
```

* switch문
```javascript
// 월을 영어로 변환한다. (11 → 'November')
var month = 11;
var monthName;

switch (month) {
  case 1: monthName = 'January'; break;
  case 2: monthName = 'February'; break;
  case 3: monthName = 'March'; break;
  case 4: monthName = 'April'; break;
  case 5: monthName = 'May'; break;
  case 6: monthName = 'June'; break;
  case 7: monthName = 'July'; break;
  case 8: monthName = 'August'; break;
  case 9: monthName = 'September'; break;
  case 10: monthName = 'October'; break;
  case 11: monthName = 'November'; break;
  case 12: monthName = 'December'; break;
  default: monthName = 'Invalid month';
  case a: case: b case: c days = 30; break; //중복도 가능
}
console.log(monthName); // November
```
* for문
```javascript
// 무한루프
for (;;) { ... }

//중첩 for문
for (var i = 1; i <= 6; i++) {
  for (var j = 1; j <= 6; j++) {
    if (i + j === 6) console.log(`[${i}, ${j}]`);
  }
}
```

while문
```javascript
// 무한루프
while (true) {
  console.log(count);
  count++;
  if (count === 3) break; 
  // 타입과 값이 같으면
}

var count = 0;

// do while문 값이 false여도 무조건 1번 실행됨
// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
// false 값이더라도 1번은 돌아감
var count = 10;
do {
  console.log(count);
  count++;
} while (count < 3);
//
```
foo레이블 식별자
```javascript
// foo라는 식별자가 붙은 레이블 블록문
foo: {
  console.log(1);
  break foo; // foo 레이블 블록문을 탈출한다.
  console.log(2); //실행 안됨!
}
```
foo를 outer라고 쓴것 뿐임 위에랑 같은 방식 탈출코드
```javascript
// outer라는 식별자가 붙은 레이블 for 문
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.
    if (i + j === 3) break outer;
    console.log(`inner [${i}, ${j}]`);
  }
}

console.log('Done!');
```
```javascript
var string = 'Hello World.';
var search = 'l';
var index;

// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.
for (var i = 0; i < string.length; i++) {
  // 문자열의 개별 문자가 'l'이면
  if (string[i] === search) {
    index = i;
    break; // 반복문을 탈출한다.
  }
}
console.log(index); // 2
//================================================================
// 참고로 String.prototype.indexOf 메서드를 사용해도 같은 동작을 한다.
console.log(string.indexOf(search)); // 2
```
console.log(String(string).indexOf(search)); 부모가 만들어놓은 객체
를 우리는 console.log(string.indexOf(search)); 이렇게 써서 불러오고
indexof메소드를 사용하게 된다.
**(.)연산자를 통한 멤버접근 래퍼객체**★★★

**String 생성자 함수 ★★**
```javascript
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
// 숫자 타입 => 문자열 타입
String(1);        // -> "1"
String(NaN);      // -> "NaN"
String(Infinity); // -> "Infinity"
// 불리언 타입 => 문자열 타입
String(true);     // -> "true"
String(false);    // -> "false"

// 2. Object.prototype.toString 메서드를 사용하는 방법
// 숫자 타입 => 문자열 타입
(1).toString();        // -> "1"
(NaN).toString();      // -> "NaN"
(Infinity).toString(); // -> "Infinity"
// 불리언 타입 => 문자열 타입
(true).toString();     // -> "true"
(false).toString();    // -> "false"

// 3. 문자열 연결 연산자를 이용하는 방법
// 숫자 타입 => 문자열 타입
1 + '';        // -> "1"
NaN + '';      // -> "NaN"
Infinity + ''; // -> "Infinity"
// 불리언 타입 => 문자열 타입
true + '';     // -> "true"
false + '';    // -> "false"
```
**Number 생성자 함수 ★★**
```javascript
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0');     // -> 0
Number('-1');    // -> -1
Number('10.53'); // -> 10.53
// 불리언 타입 => 숫자 타입
Number(true);    // -> 1
Number(false);   // -> 0

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
// 문자열 타입 => 숫자 타입
parseInt('0');       // -> 0 ★★
parseInt('-1');      // -> -1 ★★
parseFloat('10.53'); // -> 10.53 ★★

// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
+'0';     // -> 0
+'-1';    // -> -1
+'10.53'; // -> 10.53
// 불리언 타입 => 숫자 타입
+true;    // -> 1
+false;   // -> 0

// 4. * 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
'0' * 1;     // -> 0
'-1' * 1;    // -> -1
'10.53' * 1; // -> 10.53
// 불리언 타입 => 숫자 타입
true * 1;    // -> 1
false * 1;   // -> 0
```

**논리연산자★★★★★**
&& 단축평가
And연산자는 앞이false면 뒤를 확인 안함
|| 단락평가
or연산자는 앞이true면 뒤를 확인 안함
```javascript
"Cat" && "Dog" //-> "Dog"
"Cat" || "Dog" //-> "Cat"
```
**null통한 동적메모리 확인★★★**
```javascript
var elem = null;
// elem이 null이나 undefined와 같은 Falsy 값이면 elem으로 평가되고
// elem이 Truthy 값이면 elem.value로 평가된다.
var value = elem && elem.value; // -> null
//===================================================================
var elem = null;

// elem이 null 또는 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
var value = elem?.value;
console.log(value); // undefined
//===================================================================
// 좌항의 피연산자가 null 또는 undefined이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
var foo = null ?? 'default string';
console.log(foo); // "default string"
```
## 객체생성방법
  - 객체 리터럴
  - object생성자 함수
  - object.create()메서드
  - 사용자 생성자 함수
  - 클래스 사용하는 방법

**객체 리터럴**
```javascript
var person = {
  name: 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  }
};

console.log(typeof person); // object
console.log(person); // {name: "Lee", sayHello: ƒ}
//{ property key : property value }로 쓰면됨
// {} 리터럴 객체라고 함
// 함수를 객체로 가지게 되면 메서드라고 부름
```
* delete 소멸자
```javascript
var person = {
  name: 'Lee'
};

// 프로퍼티 동적 생성
person.age = 20;

// person 객체에 age 프로퍼티가 존재한다.
// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있다.
delete person.age;

// person 객체에 address 프로퍼티가 존재하지 않는다.
// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.
delete person.address;

console.log(person); // {name: "Lee"}
```

* **시험★★★★★**
```javascript
// ES5
var x = 1, y = 2; // value 부분
 
var obj1 = { x: x, y: y }; //key부분
var obj2 = { x, y };

console.log(obj1); // {x: 1, y: 2}
console.log(obj2); // {x: 1, y: 2} 익스6이상부터 지원
//key와 value가 같으면 생략을 통해 사용가능
```
* 템플릿 문자열
```javascript
const prefix = 'prop';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i };

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 원시값과 객체의 비교
**시험★★★★★**   

![원시 변수 값변경](https://user-images.githubusercontent.com/56966606/161897422-c31cb3d7-42a6-4ba0-8a56-76f14f2b737d.png)
* 변수 값 변경은 값이 갈아치워지는게 아닌 다른메모리에 할당된 변수로 주소가 참조 되는 것이다.
* 원시값은 얕은 복사도 깊은 복사 "취급"으로 받아들여진다.
* 객체의 경우에는 얕은 복사로 받아들여 진다.
```javascript
const v = 1;
const r = v;
console.log(v === r);
const obj = { name : 1};
const obj2 = obj;
console.log(obj === obj2);
```
* 둘다 같은 메모리를 참조하고있는 상태여서 값과 타입 같다.
* 결국 원시값은 값이 같으면 true 객체는 타입인 참조도 같아야 true복사형태이다.
![shallow deep copy](https://user-images.githubusercontent.com/56966606/161899008-c31ebbe5-da53-403d-b2f4-0b8ced601b81.png)

**시험★★★★★**   
* 원시값과 객체의 구별방법
1. 복사 방법
2. 비교 형태
```javascript
const o = { x: { y: 1 } }; // 2번에 걸쳐 옅은복사 참조

// 얕은 복사
const c1 = { ...o }; 
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
// 스프레드 문법으로 객체 메모리가 복사되지만 또다른 프로퍼티가key 값으로 오면 한게를 마주한다.

// 깊은 복사
const c2 = JSON.parse(JSON.stringify(o));
console.log(c1 === c2);
console.log(c1.x === c2.x);
//JSON은 객체를 모두 string으로 바꿈
//parse는 JSON의string문자들을 다시 객체로 반환하는 역할
//복사가 아닌 JSON을 통해 똑같이 만드는 것일 뿐임으로 
// 값과 메모리 상태가 다르다.

// lodash의 cloneDeep을 사용한 깊은 복사
const _ = require('lodash');
// require은 lodash"모듈"을 가져오는 역할
// 깊은 복사
const c3 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
```
**결국 원시값은 값이 같아야하고 객체는 참조가 같아야 한다.**
```javascript
var person = { name: 'Lee' };
// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```
```javascript
// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
changeVal(num, person);

// 원시값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```
* 객체는 참조값을 넘기기에 다른 메서드나 객체에 의해 값 변경이 이루어 질 수있다.
* 원시값은 값복사만 일어나기에 원형을 유지한다. 

### 함수
**★★★함수 리터럴 표현식**
```javascript
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
* var f 선언이 붙고 ;로 객체로 취급한다
* add호출이 불가하고 add함수를 f로 선언하기로 약속한것이다.

**★★★그룹연산자사용으로 즉시함수식으로 변형**
```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // 함수문

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); })(); // 즉시실행 함수식
bar(); // ReferenceError: bar is not defined
```
* ()붙이면 식이 되고 없에면 문이 된다.
* 즉시 함수식은 1회성이므로 호출 불가하다.
**함수 생성자 함수**
```javascript
var add = new Function('x', 'y', 'console.log(x,y), return x + y');

console.log(add(2, 5)); // 7
```
**화살표 함수**
```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
**★★★scope!! outer와 inner 함수**
```javascript
function outer() {
  var x = 1;
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); 
    // x는 아우터의 지역변수, y는 inner의 지역변수
  } inner(); }
outer();
```
**시험!★★★callback 함수**
* 클라이언트가 기능을 서비스 코드에 삽입 가능하게하는 함수.
* 클라이언트가 가진 정책을 서비스코드에 반영 
```javascript
//Server Code
function repeat(n, f) { 
  for (var i = 0; i < n; i++) {
    f(i);  // callback
  }
}
//Client Code
var logAll = function (i) { //callback function구현
  console.log(i);
};
repeat(5, logAll); //callback function구현
repeat(5, (n) => console.log('--' + n + '--')); //callback function구현
repeat(5, function(a){console.log(a,a,a);}); //callback function구현
```
* 콜백 함수를 사용한 이벤트 처리
```javascript
document.getElementById('myButton').addEventListener('click', function () {
  console.log('button clicked!');
});

// 콜백 함수를 사용한 비동기 처리
setTimeout(function () {
  console.log('1초 경과');
}, 1000);
```
* 고차함수 3가지
```javascript
var res = [1, 2, 3].map(function (item) {
  return item * 2; });
console.log(res); // [2, 4, 6]

res = [1, 2, 3].filter(function (item) {
  return item % 2; });
console.log(res); // [1, 3]

res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur; }, 0);
console.log(res); // 6
```
* map과 filter는 배열 생성 reduce는 단 1개의 값만 생성 

* 순수 함수
```javascript
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.
// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}
// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1
```
* 비순수 함수
```javascript
var count = 0; 
// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}
// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1
```


### Scope
* Scope란 우리말로 '범위' 변수에 접근 할 수있는 유효범위라고 한다.
* 자스 스코프는 2가지 타입이 있다 바로 global(전역)과 local(지역)

```javascript
var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수

if (true) {
  var var2 = 2; // 코드 블록 내에서 선언한 변수
  if (true) {
    var var3 = 3; // 중첩된 코드 블록 내에서 선언한 변수
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언한 변수

  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언한 변수
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```
* 전역 변수로써 var는 활용되지만 함수안에서는 함수로써 변수로만 활동한다.
* 함수범위로써의 변수라고 한다. 함수이외는 전부 전역 변수 if else등 무시.

* const 확실히 사용에 대문자를 이용해 표현 
```javascript
const Tax = 0.1;
```
**중요!!!!!**
* 일반 cosnt는 값 변경이 불가능하다.
* 그러나 const 참조 객체는 참조값의 값 변경이 가능하다!
```javascript
const person = {
  name: 'Lee'
};

// 객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.
person.name = 'Kim';

console.log(person); // {name: "Kim"}
```
### 객체의 속성 
* 객체에는 여러 속성을 가질 수 있음 함수, 값 등
```javascript
/ 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
person.sayHello = function () {
  console.log('Hi! My name is ' + this.name); 
};
console.log(person); // {name: "Lee", sayHello: ƒ}
person.sayHello(); // Hi! My name is Lee
```
**프로토 타입 객체!! 시험**
* 자바스크립트 자체 내부에서 사용하는 엔진 구조
 - 내부 슬롯
  + 프로퍼티
  + 메소드
```javascript
const o = {};

// 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다.
o.[[Prototype]] // -> Uncaught SyntaxError: Unexpected token '['
// 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.
o.__proto__ // -> Object.prototype
```
* 모든 객체는 Prototpye이라는 요소를 가진다. [[Prototype]]
  - __proto__  [[Prototype]]의 접근자속성라고하고 이렇게 사용한다.
  - __proto__ 객체는 또한 getter, setter 라는 access속성을 가짐
```javascript
const person = {
  name: 'Lee'
};
person.age = 20;
console.log(Object.getOwnPropertyDescriptor(person));
// Object는 생성자의 메서드!! 
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
// 중요한 점은 이 메서드는 단 1개만 존재하는 클래스로써 여러 사용이 불가함.
```
![prototype1](https://user-images.githubusercontent.com/56966606/162617815-1dd6b541-1604-49e3-befb-3fb267497a1b.png)
* 모든 생성자함수만이 prototype속성을 가지고 있다.
* 생성자 함수가 가진 prototype 속성을 이용하여 최상위 부모객체가 존재하게 된다.
* 최상위 부모객체(object.prototype)는 Prototype속성을 가지지 않는다.
* 생성자 함수와 다른 객체요소는 이 프로토타입에 의존한다.
* 생성자 함수&부모객체를 제외한 의존 객체는 모두 prototype을 가진다.
* 프로토타입에 의해 만들어진 객체는 __p__로 참조가능하다.
```javascript
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 인스턴스의 생성
const circle1 = new Circle(5);  // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```




```javascript
function Circle(radius) {
  // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.

  // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };

  // 3. 암묵적으로 this를 반환한다.
  // 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.
  return 100;
}

// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.
const circle = new Circle(1);
console.log(circle); // Circle {radius: 1, getDiameter: ƒ}
```


```javascript
function foo() {}

// 일반적인 함수로서 호출: [[Call]]이 호출된다.
foo();

// 생성자 함수로서 호출: [[Construct]]가 호출된다.
new foo();
```

```javascript
// 일반 함수 정의: 함수 선언문, 함수 표현식
function foo() {}
const bar = function () {};
// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.
const baz = {
  x: function () {}
};

// 일반 함수로 정의된 함수만이 constructor이다.
new foo();   // -> foo {}
new bar();   // -> bar {}
new baz.x(); // -> x {}

// 화살표 함수 정의
const arrow = () => {};

new arrow(); // TypeError: arrow is not a constructor

// 메서드 정의: ES6의 메서드 축약 표현만을 메서드로 인정한다.
const obj = {
  x() {}
};

new obj.x(); // TypeError: obj.x is not a constructor
```

* console.dir 
 + 단 1개의 객채만을 출력하기 위한 코드
```javascript
function square(number) {
  return number * number;
}
console.dir(square);
// 객체 정보를 출력한다.
```
**객체 Object의 프로토타입**
```javascript
function square(number) {
  return number * number;
}

console.log(Object.getOwnPropertyDescriptors(square));
/*
{
  length: {value: 1, writable: false, enumerable: false, configurable: true},
  name: {value: "square", writable: false, enumerable: false, configurable: true},
  arguments: {value: null, writable: false, enumerable: false, configurable: false},
  caller: {value: null, writable: false, enumerable: false, configurable: false},
  prototype: {value: {...}, writable: true, enumerable: false, configurable: false}
}
*/

// __proto__는 square 함수의 프로퍼티가 아니다.
console.log(Object.getOwnPropertyDescriptor(square, '__proto__')); // undefined

// __proto__는 Object.prototype 객체의 접근자 프로퍼티다.
// square 함수는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}
```

* 유사배열& iterator
 + 자바스크립트는 여러개의 개체를 참조 할수있다.
 + 유사배열 객체는 length프로퍼티와 []연산자등 배열관련 요소를 가지고있다.
 + 객체.[Symbol.iterator]();라고 이터러블 선언을 할 수 있다.
* 배열 객체
```javascript
unction sum() {
  // arguments 객체를 배열로 변환
  const array = Array.prototype.slice.call(arguments);
  return array.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}
console.log(sum(1, 2));          // 3
console.log(sum(1, 2, 3, 4, 5)); // 15
```
* 중요한 점은 Array생성자 함수 의 프로토타입의 slice기능을 사용 할 수있다는 것.
* 자스는 논리적으로 slice기능을 자삭객체가 자기것인 것처럼 쓸 수 있다.

**객체 프로토타입 프로퍼티 확인**
```javascript
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log(obj.__proto__ === Object.prototype); // true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다.
console.log(obj.hasOwnProperty('a'));         // true
console.log(obj.hasOwnProperty('__proto__')); // false
```

```javascript
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```
()소괄호
{}중괄호
[]대괄호
객체 접근방법
```javascript
var a = { name : 'hong', age : 30 };
a.name;
a["name"];
```
* 객체와 함수
* 객체생성 방법
  + 생성자 함수
  ```javascript
  var a = new object();
  console.log(o1.__proto__);  // [Object: null prototype] {}
  console.log(Object.prototype);  // [Object: null prototype] {}
  console.log(o1.__proto__.__proto__);    // null
  console.log(Object.prototype.__proto__);    // null
  ```
  + 리터럴 객체
  ```javascript
  var a = { };
  ```
```javascript
const Person = (function(){
    function Person(n, a){
        this.name = n;
        this.age = a;
    }
    Person.prototype.toString = function ()
    {
        // 프로토타입 메서드 재정의
        return `name: ${this.name}, age: ${this.age}`;
        // 메서드 쉐도잉& 오버라이딩
        // Person 프로토타입에 직접 재정의
    }
    Person.print = function(){ console.log("생성자 함수 Person"); }
    // 생성자 함수의 메서드이며 객체에 상속되는 메서드는 아니다.

    return Person;
}());
// 변수와 함수를 같이 세트로 활용하기에 위해 즉시실행함수로 묶는다.
let p1 = new Person('hong', 25);
let p2 = new Person('lee', 30);
console.log(p1.toString());
console.log(p2.toString());
Person.print();
```
**이를 바탕으로 프로토타입 체인 만들기 시험!**
![proto](https://user-images.githubusercontent.com/56966606/165665871-e2c31e9d-65ee-4ac2-95a7-e05c6d9e92e2.png)
```javascript
const Person = (function(){
    function Person(n, a){
        this.name = n;
        this.age = a;
    }
    Person.prototype.toString = function ()
    {
        return `name: ${this.name}, age: ${this.age}`;
    }
    Person.print = function(){ console.log("생성자 함수 Person"); }
    return Person;
}());
// 프로토타입 바꿔보기
let proto = {
    constructor : Person,
    toString : function(){
        console.log("prototype toString()");
    } ,
    getName : function(){
        return this.name;
    } ,
    getAge : function(){
        return this.age;
    }
}
Person.prototype = proto;
let p1 = new Person('hong', 25);
console.log(p1.toString());
console.log(p1.getName);
console.log(p1.getAge);
```
# 기말 2차시
## **엄격모드 'use strict'**
 ```javascript
 // 키워드 없이 문법 선언 못하도록 하는 'use strict';
 (function foo(){
  'use strict';
  x = 10; // 'use strict' 때문에 출력 에러가 발생한다.
})();
 ```
* 'use strict'를 통해 함수 내에서만 사용가능하다.
* let, var, const 없이 만들면 전역 변수 취급이된다.
* 'use strict'는 매개 변수 중복 사용 불가능
```javascript
(function () {
  'use strict';
  //SyntaxError: Duplicate parameter name not allowed in this context
  function foo(x, x) { return x + x; }
  console.log(foo(1, 2));
}());
```
* with 사용불가
**'use strict에서 'this의 동작방식**
```javascript
function foo(){
    console.log(this); // undefined    
}
```
* 전역함수에서 'use strict'일때 this는 undefined값을 가진다.
* 'use strict'전역함수에서 this는 전역객체로써 동작한다.
**html에서의 엄격모드**
```html
<!DOCTYPE html>
<html>
<body>
  <script>'use strict';</script>
  
  <script>
    // 스크립트 내 엄격모드 코드가 없어서 잘 작동한다.
    x = 1; // 에러가 발생하지 않는다.
    console.log(x); // 1
  </script>
  
  <script>
    'use strict';
    y = 1; // ReferenceError: y is not defined
    console.log(y);
  </script>
  
</body>
</html>
```
**변경된 인수가 arguments 객체에 반영되지 않는다.**
```javascript
(function (a) {
  'use strict';
  // 매개변수에 전달된 인수를 재할당하여 변경
  a = 2;

  // 변경된 인수가 arguments 객체에 반영되지 않는다.
  console.log(arguments); // { 0: 1, length: 1 }
}(1));
```

**built in 객체**
```javascript
const uri  = 'http://example.com?name=이웅모&job=programmer&teacher'; 
let enc = encodeURIComponent(uri); // 한글 같은 요소를 바꿔준다.
console.log(enc);
// 글로벌 서버를 사용하기 위해서 주소로 url은 표준 주소로 바꿔줘야한다.
// 지역적 특성을 가진 요소를 넣으면 안된다,
let dec = decodeURIComponent(uri);
console.log(dec);
```

## **중요!!! 파트 this**
```javascript
const circle = {
    radius : 5,
    getDiameter(){ return 2 * circle.radius; }
};
// new와 함게 생성된 참조 식별자(만들어진 자기 자신)를 this라고 한다.
```
* 리터럴 객체 내 this는 리터럴 자체이다.
```javascript
circle.prototype.getDiameter = function(){
    return 2 * this.radius;
}
```
* 프로토타입선언 객체에서의 this는 이 함수를 호출한 객체가 this가 된다.
**함수 호출 방식 4가지에서의 this**
1. 일반 함수 호출
```javascript
//this는 전역 객체 window를 가르킨다.
const foo = function(){
    console.dir(this);
}
```
2. 메서드 호출
```javascript
const foo = function(){
    console.dir(this);
}
//foo는 함수 내부의 this는 메서드를 호출한 객체 obj를 가르킨다.
const obj = { foo : foo };
obj.foo();
```
3. 생성자 함수 호출
```javascript
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 반지름이 5인 Circle 객체를 생성
const circle1 = new Circle(5); // new를 통한 생성자 함수 호출!
// 반지름이 10인 Circle 객체를 생성
const circle2 = new Circle(10); // new를 통한 생성자 함수 호출!

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```
**4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출 시험!!!**
```javascript
//foo 함수 내부의 this는 인수에 의해 결정된다.
const foo = function(){
  console.dir(this);
}
const bar = { name : 'bar' };
foo.call(bar, 1, 2, 3); //this를 리스트를 내가 원하는 인수로 결정해서 함수호출
//bar.foo(1, 2, 3);랑 똑같음
foo.apply(bar, [1, 2, 3]); //this를 배열로 내가 원하는 인수로 결정해서 함수호출
//bar.foo([1, 2, 3]);랑 똑같음
foo.bind(bar)(1, 2, 3); //this를 바인딩한 함수를 반환한다.
//bar.foo();
```
**리터럴 내 전역 메서드는 일반 메서드 형식으로 판단된다.**
```javascript
// var 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티다.
var value = 1;
// const 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티가 아니다.
// const value = 1;

const obj = {
  value: 100,
  foo() {
    console.log("foo's this: ", this);  // {value: 100, foo: ƒ}
    console.log("foo's this.value: ", this.value); // 100

    // 메서드 내에서 정의한 중첩 함수
    function bar() {
      console.log("bar's this: ", this); // window
      console.log("bar's this.value: ", this.value); // 1
    }

    // 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.
    bar();
  }
};
**콜백 함수는 일반함수**
```javascript
var value = 1;

const obj = {
  value: 100,
  foo() {
    console.log("foo's this: ", this); // {value: 100, foo: ƒ}
    // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.
    setTimeout(function () {
      console.log("callback's this: ", this); // window
      console.log("callback's this.value: ", this.value); // 1
    }, 100);
  }
};

obj.foo();
```
**배열이 아닌것들을 배열 객체로 반환하는 방법**
```javascript
function convertArgsToArray(){
    console.log(arguments); // arguments 유사 배열
    // const arr = Array.prototype,slice.call(arguments);
    // 객체는 프로토타입의 상속 되있기에 프토토타입 안에 정의된 slice함수도 사용가능하다.
    console.log(arr);
    const arr = Array.prototype.slice.call(arguments);
    console.log(arr);
    return arr;
}
//=====================================================================
const a = [1,2,3];
const b = a.slice(1, 3); // 1포함한 3이하의 숫자까지 배열을 자르겠다. 
// == const b = Array.prototype.slice.apply(a,[1,3]);
console.log(a);
console.log(b); //[ 1, 2 ]
```
* argument를 통한 유사배열로 바꾸기
* Array의 함수 사용해서 바꾸기
**this를 person 객체로 바꿔보기**
```javascript
const person = {
  name: 'Lee',
  foo(callback) {
    // ①
    setTimeout(callback, 100);
  }
};
person.foo(function () {
  console.log(`Hi! my name is ${this.name}.`); // ② Hi! my name is .
  // 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.
  // 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.
  // Node.js 환경에서 this.name은 undefined다.
});
```

## **closure 중요!!**
* 함수가 꼭 있어야하며 외부변수 참조를 가지는 상태여야 한다.
* 함수가 외부변수를 참조할때 리턴 되지않고 남아있는 상태.
**자스가 코드 참조하는 순서 **
```javascript
const x = 1; // 3

function outerFunc() { // 2
    const x = 10;
    innerFunc();
}
function innerFunc(){ // 1
    console.log(x); 
}
outerFunc();
```
1. inner
2. outer
3. 전역
4. 마지막은 undefined

****
```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 클로저
      // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
      function bar() {
        debugger;
        // Debugger는 소스코드 중간에 웹에서 디버거에서 멈추게 할수 있다.(일시정지)
        console.log(x); 
        // console.log(x)에서 x를 참조하고 있다.
        // 때문에 함수를 실행해도 x값은 리턴되고나서 없어지지않고 메모리상 남아있으며 클로저가 실행된다.
      }
      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```
* 디버거로 먼춰두면 x를 계속 참조하는 상태가 되어서 클로서를 확인할 수 있다.
* 원래 클로서는 일반 컴팡일링에서 확인 불가하다.
```javascript
const increase = (function(){
    let num = 0;
    //클로저
    let bar = function(){
        return ++num;
    };
    return bar;
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```
# 기말 3차시 
![Person_prototype](https://user-images.githubusercontent.com/56966606/169195039-ac9e22dd-f69c-4831-9b57-6a1421b98d2b.png)
![Animal_prototype](https://user-images.githubusercontent.com/56966606/169195047-1088b747-4c25-4f0f-bc9c-cb0d0e8a58ba.png)
### 클로저
**지역 변수로 선언된 클로저**
```javascript
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private
}
// 프로토타입 메서드
Person.prototype.sayHi = function () {
  // Person 생성자 함수의 지역 변수 _age를 참조할 수 없다
  console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
};
```
* 내부에서 선언된 age는 클로저로 작동된다.

**생성자 패턴**
```javascript
const Person = (function () {
  let _age = 0; // private

  // 생성자 함수
  function Person(name, age) {
    this.name = name; // public
    _age = age;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  // 생성자 함수를 반환
  return Person;
}());
const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.

// _age 변수 값이 변경된다!
me.sayHi(); // Hi! My name is Lee. I am 30.
```
* age는 지역 값이라 클로저가 반환되면 같이 없어진다.
 
 **외부 데이터 멤버와 프로토타입 함수를 가지는 객체**
 ```javascript
const Person = (function{
    let_age = 0;

    //생성자 함수
    function Person(name, age){
        this.name = name;
        _age = age; //클로저 외부 참조 불가
    }
    //prototype
});
```
**var 전역변수**
```javascript
var funcs = [];
for(var i = 0; i < 3; i++){
    funcs[i] = function() {return i;};
}
// i부분 출력은 0, 1 ,2지만
// j부분에서 전역 funcs배열이 영향 받기에 출려값이 3이다.
for(var j = 0; j < funcs.length; j++){
    console.log(funcs[j]());
}
```
* var의 전역변수
* 최종적으로 3값을 가진다.
* 이걸 고치려면 var 사용을 지양해야한다.

## 클래스 중요파트!!
**기존의 생성자 함수로 객체생성 방법**
```javascript
(function Perosn(name){
    this.name = name;

    Perosn.prototype.sayHi = function(){
        console.log("Hi my name is " + this.name);
    }
})();
const o1 = new Person("lee");
const o2 = new Person("park");

console.log(o1, o2);
```
```javascript
var Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log('Hi! My name is ' + this.name);
  };

  // 생성자 함수 반환
  return Person; //생략 되어있다
}());

// 인스턴스 생성
var me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee
```
* 둘다 똑같은 방식으로 작동한다.

**클래스 표현식**
```javascript
class Person {}
```

**시험부분!!**
* 클래스에서 constructor는 무조건 사용해야 한다.
* constructor는 생성자의 역할을 한다
* 클래스안에 메서드로 인식된다
* sayHi 프로토타입 메서드등등
```javascript
class Perosn {
    constructor(name){ //생성자
    // 인스턴스 생성 및 초기화
        this.name = name; // name 프로퍼티는 public하다.
    }
     // 프로토타입 메서드
    sayHi(){
        console.log(`Hi! My name is ${this.name}`);
    }
    // 정적 메서드
    static sayHello(){ //생성자가 가진 sayhello
        console.log("Hello");
    }
}
const p1 = new Person("Lee"); //인스턴스 생성
// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```


* 클래스는 생성자, 메서드, 정적 메서드 3가지밖에 안가지고 있다.
* 클래스는 인스턴스 생성시 new를 무조건 사용해야한다.
**25-11 생성자와 변수 선언**
```javascript
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}
```
* constructor는 정수 반환이 안된다.
**25-24 시험!!! prototype 확인**
```javascript
// me 객체의 프로토타입은 Person.prototype이다.
Object.getPrototypeOf(me) === Person.prototype; // -> true
me instanceof Person; // -> true

// Person.prototype의 프로토타입은 Object.prototype이다.
Object.getPrototypeOf(Person.prototype) === Object.prototype; // -> true
me instanceof Object; // -> true

// me 객체의 constructor는 Person 클래스다.
me.constructor === Person; // -> true
```
**25-31 5개의 생성자의 정적메서드 알아두기**
```javascript
// 표준 빌트인 객체의 정적 메서드
Math.max(1, 2, 3);          // -> 3
Number.isNaN(NaN);          // -> true
JSON.stringify({ a: 1 });   // -> "{"a":1}"
Object.is({}, {});          // -> false
Reflect.has({ a: 1 }, 'a'); // -> true
```
**25-32 생성자 작동 순서**
```javascript
class Person {
  // 생성자
  constructor(name) {
    // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    console.log(this); // Person {}
    console.log(Object.getPrototypeOf(this) === Person.prototype); // true

    // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.name = name;

    // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
  }
}
```
**25-35 시험!! 클래스와 리터럴 객체의 차이**
```javascript
const person = {
  // 데이터 프로퍼티
  firstName: 'Ungmo',
  lastName: 'Lee',

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  // setter 함수
  set fullName(name) {
    // 배열 디스트럭처링 할당: "36.1. 배열 디스트럭처링 할당" 참고
    [this.firstName, this.lastName] = name.split(' ');
  }
};

// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.
console.log(`${person.firstName} ${person.lastName}`); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
person.fullName = 'Heegun Lee';
console.log(person); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(person.fullName); // Heegun Lee

// fullName은 접근자 프로퍼티다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
console.log(Object.getOwnPropertyDescriptor(person, 'fullName'));
// {get: ƒ, set: ƒ, enumerable: true, configurable: true}
```
```javascript
class Person{
    name = "lee";

    constructor(){
        this.name = "Lee";
    }
}
```
* name은 클래스 필드 선언이다.
* 두개는 똑같은 방식의 클래스 필드 생성자 이다.
**중요 25-46 클래스내에 getName은 함수 프로퍼티이지 메서드가 아니다.**
```javascript
class Person {
  // 클래스 필드에 문자열을 할당
  name = 'Lee';

  // 클래스 필드에 함수를 할당
  getName = function () {
    return this.name;
  }
  // 화살표 함수로 정의할 수도 있다.
  // getName = () => this.name;
}

const me = new Person();
console.log(me); // Person {name: "Lee", getName: ƒ}
console.log(me.getName()); // Lee
```
* getName = function(){}은 일반 함수, getName(){}은 메서드이며 프로토타입에서 생성이 된다.

**중요 25-47 doom과 이벤트 핸들러 increase의 this는 app객체를 가르킨다**
```html
<!DOCTYPE html>
<html>
<body>
  <button class="btn">0</button>
  <script>
    class App {
      constructor() {
        this.$button = document.querySelector('.btn');
        this.count = 0;

        // increase 메서드를 이벤트 핸들러로 등록
        // 이벤트 핸들러 increase 내부의 this는 DOM 요소(this.$button)를 가리킨다.
        // 하지만 increase는 화살표 함수로 정의되어 있으므로
        // increase 내부의 this는 인스턴스를 가리킨다.
        this.$button.onclick = this.increase;

        // 만약 increase가 화살표 함수가 아니라면 bind 메서드를 사용해야 한다.
        // $button.onclick = this.increase.bind(this);
      }

      // 인스턴스 메서드
      // 화살표 함수 내부의 this는 언제나 상위 컨텍스트의 this를 가리킨다.
      increase = () => this.$button.textContent = ++this.count;
    }
    new App();
  </script>
</body>
</html>
```
**상속 25-54 자식은 생성자로 만들어져 constructor가 없기에 부모인 animal의 constructor를 호출한다.**
```javascript
class Animal {
  constructor(age, weight) {
    this.age = age;
    this.weight = weight;
  }

  eat() { return 'eat'; }

  move() { return 'move'; }
}

// 상속을 통해 Animal 클래스를 확장한 Bird 클래스
class Bird extends Animal {
  fly() { return 'fly'; }
}

const bird = new Bird(1, 5);

console.log(bird); // Bird {age: 1, weight: 5}
console.log(bird instanceof Bird); // true
console.log(bird instanceof Animal); // true

console.log(bird.eat());  // eat
console.log(bird.move()); // move
console.log(bird.fly());  // fly
```
**25-60 자식 클래스입장에서 ...arg 배열로 매개변수를 받는 rest 파라미터 , super(...arg)은 스프레드 문법 부모거를 가져온다.**
```javascript
constructor(...args) { super(...args); }
```
**25-64 암기 기본적인거임 ㅇㅇ**
```javascript
// 수퍼클래스
class Base {
  constructor(a, b) { // ④
    this.a = a;
    this.b = b;
  }
}

// 서브클래스
class Derived extends Base {
  constructor(a, b, c) { // ②
    super(a, b); // ③
    this.c = c;
  }
}

const derived = new Derived(1, 2, 3); // ①
console.log(derived); // Derived {a: 1, b: 2, c: 3}
```
**25-65 자식이 부모 거를 가져와야해서 super를 통해서 무조건 먼저 가져와야한다.**
```javascript
class Base {}

class Derived extends Base {
  constructor() {
    // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    console.log('constructor call');
  }
}

const derived = new Derived();
```
**25-68 자식이 상속 받은 것을 명시적으로 표현하는 법 안하면 재귀함가 되어버림**
```javascript
// 수퍼클래스
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

// 서브클래스
class Derived extends Base {
  sayHi() {
    // super.sayHi는 수퍼클래스의 프로토타입 메서드를 가리킨다.
    return `${super.sayHi()}. how are you doing?`;
  }
}

const derived = new Derived('Lee');
console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```
**25-80 배열 만드는 법 reduce, filter 통해 배열 연산**
```javascript
// Array 생성자 함수를 상속받아 확장한 MyArray
class MyArray extends Array {
  // 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] => [1, 2, 3]
  uniq() {
    return this.filter((v, i, self) => self.indexOf(v) === i);
  }

  // 모든 배열 요소의 평균을 구한다: [1, 2, 3] => 2
  average() {
    return this.reduce((pre, cur) => pre + cur, 0) / this.length;
  }
}

const myArray = new MyArray(1, 1, 2, 3);
console.log(myArray); // MyArray(4) [1, 1, 2, 3]

// MyArray.prototype.uniq 호출
console.log(myArray.uniq()); // MyArray(3) [1, 2, 3]
// MyArray.prototype.average 호출
console.log(myArray.average()); // 1.75
```
**25-82 자식인 myArray를 호출한다.**
```javascript
// 메서드 체이닝
// [1, 1, 2, 3] => [ 1, 1, 3 ] => [ 1, 3 ] => 2
console.log(myArray.filter(v => v % 2).uniq().average()); // 2
```
**25-83 static get [Symbol.species]() {return Array;}로 부모타입을 반환 할 수있게한다.**
```javascript
// Array 생성자 함수를 상속받아 확장한 MyArray
class MyArray extends Array {
  // 모든 메서드가 Array 타입의 인스턴스를 반환하도록 한다.
  static get [Symbol.species]() { return Array; }

  // 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] => [1, 2, 3]
  uniq() {
    return this.filter((v, i, self) => self.indexOf(v) === i);
  }

  // 모든 배열 요소의 평균을 구한다: [1, 2, 3] => 2
  average() {
    return this.reduce((pre, cur) => pre + cur, 0) / this.length;
  }
}

const myArray = new MyArray(1, 1, 2, 3);

console.log(myArray.uniq() instanceof MyArray); // false
console.log(myArray.uniq() instanceof Array); // true

// 메서드 체이닝
// uniq 메서드는 Array 인스턴스를 반환하므로 average 메서드를 호출할 수 없다.
console.log(myArray.uniq().average());
// TypeError: myArray.uniq(...).average is not a function
```
### 함수의 추가 기능
**고차 함수 map**
```javascript
// 콜백 함수를 사용하는 고차 함수 map. 콜백 함수도 constructor이며 프로토타입을 생성한다.
[1, 2, 3].map(function (item) {
  return item * 2;
}); // -> [ 2, 4, 6 ]
```
**콜백 함수 구현**
```javascript
function server( f ){
    console.log('server()');
    f();// 콜백
    console.log('server()');
}
function client(){// 콜백함수
    console.log("client()");
}
server( client );
// map함수를 통한 콜백함수 구현
function m(item) {
    return item + 10;
}
console.log([1,2,3].map(m));
```
**26-14 람다식**
```javascript
const arrow = (x, y) => {   
console.log(x, y);
}
console.log(arrow(1, 2));
```
**26-18 람다식2**
```javascript
const create = (id, content) => ({ id, content });
create(1, 'JavaScript'); // -> {id: 1, content: "JavaScript"}

// 위 표현은 다음과 동일하다.
const create = (id, content) => { return { id, content }; };
```
**26-21**
```javascript
const person = (name => ({
  sayHi() { return `Hi? My name is ${name}.`; }
}))('Lee');

console.log(person.sayHi()); // Hi? My name is Lee.
```

# 26-22

```javascript
// ES5
[1, 2, 3].map(function (v) {
  return v * 2;
});

// ES6
[1, 2, 3].map(v => v * 2); // -> [ 2, 4, 6 ]
```
* 화살표함수는 생성자가 없음 고로 프로토타입도 없음
**26-34 this는 a:1로 정하게하는 방법 call**
```javascript
// 중첩 함수 foo의 상위 스코프는 즉시 실행 함수다.
// 따라서 화살표 함수 foo의 this는 상위 스코프인 즉시 실행 함수의 this를 가리킨다.
(function () {
  const foo = () => console.log(this);
  foo();
}).call({ a: 1 }); // { a: 1 }

// bar 함수는 화살표 함수를 반환한다.
// bar 함수가 반환한 화살표 함수의 상위 스코프는 화살표 함수 bar다.
// 하지만 화살표 함수는 함수 자체의 this 바인딩을 갖지 않으므로 bar 함수가 반환한
// 화살표 함수 내부에서 참조하는 this는 화살표 함수가 아닌 즉시 실행 함수의 this를 가리킨다.
(function () {
  const bar = () => () => console.log(this);
  bar()();
}).call({ a: 1 }); // { a: 1 }
```
**매우엄청중요! 26-44**
```javascript
// Bad
class Person {
  // 클래스 필드 정의 제안
  name = 'Lee';
  sayHi = () => console.log(`Hi ${this.name}`);
}

const person = new Person();
person.sayHi(); // Hi Lee
```
* sayHi는 메서드아니고 this는 누구거인지 물어보는 문제

# 기말 4차시
**배열 기초**
```javascript
const arr = ['apple', 'banana', 'orange'];
arr[0] = "apple2"; 
console.log(arr); // const 여도 수정되어 출력이 된다.

console.log(Object.getOwnPropertyDescriptors(arr)); // arr가 가진 속성 확인
console.log(arr.length); // 3 // arr가 가진 property 
```
* 배열은 참조값이 const가 되어있지 내부 프로퍼티 값이 const가 아니기에 수정이 가능하다.

**27-06 배열은 모두 Array의 프로퍼티이다.**
```javascript
const arr = [1,2,3];
console.log(arr.constructor === Array);
console.log(Object.getPrototypeOf(arr) === Array.prototype);
```

**선형 검색을 통해 배열(array)에 특정 요소(target)가 존재하는지 확인한다.**
```javascript
const ar = [1,2,3,4,5,6,7,8,9];
function linearSearch(array, target){
  const length = array.length;

  for(let i = 0; i < length; i++){
    if(array[i] === target) return i;
  }

  return -1;
}
console.log(linearSearch(ar, 3));
console.log(linearSearch(ar, 0));
```
* 배열에 특정 요소가 존재하면 특정 요소의 인덱스를 반환하고, 존재하지 않으면 -1을 반환한다.

**string 값이 둘이 같은 time과 timeEnd두개를 추적해 arr배열이 도는데 걸리는 시간**
```javascript
console.time('Array Persormance Test');   
console.timeEnd('Array Persormance Test');
```

**27-15 arr의 프로퍼티는 수정가능하지만 배열은 변경되지 않는다.**
```javascript
const arr = [1];

// 현재 length 1보다 큰 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// length 프로퍼티 값은 변경되지만 실제로 배열의 길이가 늘어나지는 않는다.
console.log(arr.length); // 3
console.log(arr); // [1, empty × 2]
```

**27-20 희소배열**
```javascript
const arr = [1, , 3]; // 희소 배열

// 희소 배열의 length는 배열의 실제 요소 개수보다 언제나 크다.
console.log(arr.length); // 3
console.log(arr);        // [1, empty, 3]
console.log(arr[1]);     // undefined
```

**27-21 중요!! 많이 사용하는 배열 확인 예시!**
```javascript
const arr = new Array(10);
console.log(arr);
console.log(arr.length);
```

**27-28 Array.from 시험 매우중요!!!!!! 배열, iterable과 유사배열을 복사 할 수 있다.
```javascript
Array.from({ length: 2, 0: 'a', 1: 'b' }); // -> ['a', 'b']
// 유사 배열 객체를 변환하여 배열을 생성한다.

Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o'];
// 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
```

**유사배열과 배열의 구성**
```javascript
const arr = [1,2,3];
const arr2 = [...arr]; // 스프레드 문법
const arr3 = Array.from(arr); 
const arr4 = Array.prototype.slice.call(arr); // 기존 배열 나열 방식

console.log(arr);
console.log(arr2);
console.log(arr === arr2);
console.log(arr === arr3);
console.log(arr === arr4);
```
* 모두 깊은 복사 방식의 배열이다.

**Array.from와 람다식**
```javascript
const ar1 = Array.from(new Array(100), (_, idx) => idx + 1);
const ar2 = Array.from({length : 100}, (_, idx) => idx + 1);
const ar3 = Array.from({length : 100}, (item, idx, arr) => idx + 1);

console.log(ar1);
console.log(ar2);
console.log(ar3);
```
* 출력 결과는 [1, 2, ... , 99, 100]으로 동일하다.

### from의 구성 중요!배열 출력
**from의 구성**
```javascript
function cb(item, index, arr){
    console.log(item, idx, arr);
    //값, index번호, 위치 3가지를 쥐어주어야 한다.
}
const arr = [10, 20, 30, 40, 50];
arr.forEach( v, i, arr ); // 콜백함수 cb
```
**배열 값 만 출력**
```javascript
function cb(item){
    console.log(item);
}
const arr = [10, 20, 30, 40, 50];
arr.forEach( cb ); // 콜백함수 cb
```
**배열 인덱스 만 출력**
```javascript
function cb(item){
    console.log(_, idx); // 언더바는 출력 하지 않겠다. 라는 뜻.
}
const arr = [10, 20, 30, 40, 50];
arr.forEach( (_, i) => console.log(i) ); // 콜백함수 cb
```
**27-35 배열 0 ~ 99 였는데 100추가하기 와 빈배열 표기**
```javascript
arr[100] = 100;

console.log(arr); // [0, 1, empty × 98, 100]
console.log(arr.length); // 101
```

**배열의 메서드**
```javascript
const arr = [1, 2, 3, 4, 5];

arr.splice(2, 1); 
console.log(arr);
console.log(arr.length);

arr.push(6);
console.log(arr);

const result = arr.concat(3);
console.log(`arr : ${arr}`);
console.log(`result : ${result}`);
```
* splice()는 (삭제를 시작할 인덱스 인텍스, 삭제할 요소 수) 매개변수로 받는다.
* push()는 원본 배열 arr를 직접 변경한다.
* concat은 새로운 배열을 만들어 반환한다.

**스프레드 문법**
```javascript
const arr = [1, 2];

const newArr = [...arr, 3];
console.log(newArr); // [1, 2, 3]
```
* 배열에만 붙을 수 있다.
* 목록으로 배열을 가지기에 []를 가져가야 한다. 

**시험!! 배열로 스택 구현**
```javascript
class Stack{
  #array; // private class member

  constructor(array = []) {
    if(!Array.isArray(array)){
      throw new TypeError(`${array} is not an array`);
    }
    this.#array = array;
  }
  pop() {
    return this.#array.pop();
  }
  push(value){
    return this.#array.push(value);
  }
  entries(){
    return [...this.#array];
  }
}
const stack = new Stack();
stack.push(10);
stack.push(20);
stack.push(30);
console.log(stack.entries());
stack.pop();
console.log(stack.entries());
```
* constructer는 자동생성이 되지 않는다.

**배열로 큐 구현**
```javascript
const Queue = (function (){
  function Queue(array = []) {
    if (!Array.isArray(array)) {
      // "47. 에러 처리" 참고
      throw new TypeError(`${array} is not an array.`);
    }
    this.array = array;
  }

  Queue.prototype = {
    constructor : Queue,
    enqueue(value){
      return this.array.push(value);
    },
    dequeue(){
      return this.array.shift();
    },
    entries(){
      return [...this.array];
    }
  };

  return Queue;
}());

const queue = new Queue([1, 2]);
console.log(queue.entries());

queue.enqueue(3);
console.log(queue.entries());
queue.dequeue();
console.log(queue.entries());
```
* **push, pop (뒤 삽입, 제거)**
* **unshift, shift (앞 삽입, 제거)**

**27-72 배열의 매서드 reduce 중요!**
```javascript
function sum(){
  var arr = Array.prototype.slice.call(arguments);
  console.log(arr);

  // reduce는 콜백기반
  return arr.reduce(function (pre, cur){
    return pre + cur;
  }, 0);
  // 람다식 표현
  return arr.reduce((pre, cur) => pre + cur, 0);
}
console.log(sum(1, 2, 3));
```

**중첩배열 평탄화 flat메서드**
```javascript
// 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.
[1, [2, [3, [4]]]].flat();  // -> [1, 2, [3, [4]]]
[1, [2, [3, [4]]]].flat(1); // -> [1, 2, [3, [4]]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.
[1, [2, [3, [4]]]].flat(2); // -> [1, 2, 3, [4]]
// 2번 평탄화한 것과 동일하다.
[1, [2, [3, [4]]]].flat().flat(); // -> [1, 2, 3, [4]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.
[1, [2, [3, [4]]]].flat(Infinity); // -> [1, 2, 3, 4]
```

**배열의 sort와 2항 predicate**
```javascript
const points = [40, 100, 1, 5, 2, 25, 10];

points.sort((a, b) => a - b);
console.log(points);

points.sort((a, b) => b - a);
console.log(points);

console.log(points[0]);
```
* 숫자 배열의 오름차순 정렬. 비교 함수의 반환값이 0보다 작으면 a를 우선하여 정렬한다.
* 숫자 배열의 내림차순 정렬. 비교 함수의 반환값이 0보다 작으면 b를 우선하여 정렬한다.
* 숫자 배열에서 최대값 취득한다.
* predicate 는 원래 bool형식 sort에서는 정수형으로 -1, 0, 1 3가지를 반환한다.

# 기말 5차시
**34-01배열, 문자열, Map, Set 등은 이터러블이다.**
```javascript
const isIterable = v => v !== null && typeof v[Symbol.iterator] === 'function';

// 배열, 문자열, Map, Set 등은 이터러블이다.
isIterable([]);        // -> true
isIterable('');        // -> true
isIterable(new Map()); // -> true
isIterable(new Set()); // -> true
isIterable({});        // -> false
```
**34-02 유사배열과 배열의 이터러블 활용**
```javascript
const array = [1, 2, 3];

// 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다.
console.log(Symbol.iterator in array); // true

// 이터러블인 배열은 for...of 문으로 순회 가능하다.
for (const item of array) {
  console.log(item);
}

// 이터러블인 배열은 스프레드 문법의 대상으로 사용할 수 있다.
console.log([...array]); // [1, 2, 3]

// 이터러블인 배열은 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.
const [a, ...rest] = array;
console.log(a, rest); // 1, [2, 3]
```
**rest 파라미터**
```javascript
function print(...arr){
      console.log(arr);
  }
  print(1,2,3);
  print(100, 200);
// 0번째 배열 값만 받고 나머지는 배열로 받는 rest파라미터
  function print(n, ...arr){
      console.log(n, ',',arr);
  }
  print(1,2,3);
  print(100, 200);
  
  const arr = [1,2,3,4,5];
  console.log(arr);
  console.log(carr);
  console.log(carr === arr);
```

**34-06 이터러블이 가진 이터레이터 객체 메서드**
```javascript
/*
Symbol.iterator 프로퍼티 메서드 / 이 메서드를 반환하면 이터러블
iterator 객체는 next객체를 가지고 next는 result객첼르 가지고 그 안에는 done, value라는 메서드를 가진다.
배열은 이터러블 프로토콜을 준수한 이터러블이다.
*/
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터레이터를 반환한다. 이터레이터는 next 메서드를 갖는다.
const iterator = array[Symbol.iterator]();

// next 메서드를 호출하면 이터러블을 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를
// 반환한다. 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```
* 유사배열 객체는 이터러블이 아니다.

**34-17 이터러블이면서 이터레이터인 객체를 반환하는 함수**
```javascript
const fibonacciFunc = function (max) {
  let [pre, cur] = [0, 1];

  // Symbol.iterator 메서드와 next 메서드를 소유한 이터러블이면서 이터레이터인 객체를 반환
  return {
    [Symbol.iterator]() { return this; },
    // next 메서드는 이터레이터 리절트 객체를 반환
    next() {
      [pre, cur] = [cur, pre + cur];
      return { value: cur, done: cur >= max };
    }
  };
};

// iter는 이터러블이면서 이터레이터다.
let iter = fibonacciFunc(10);

// iter는 이터러블이므로 for...of 문으로 순회할 수 있다.
for (const num of iter) {
  console.log(num); // 1 2 3 5 8
}

// iter는 이터러블이면서 이터레이터다
iter = fibonacciFunc(10);

// iter는 이터레이터이므로 이터레이션 리절트 객체를 반환하는 next 메서드를 소유한다.
console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: 5, done: false }
console.log(iter.next()); // { value: 8, done: false }
console.log(iter.next()); // { value: 13, done: true }
```
**35-01스프레드는 배열이면서 이터러블 객체여야 한다.**
```javascript
// ...[1, 2, 3]은 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3)
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(...'Hello'); // H e l l o

// Map과 Set은 이터러블이다.
console.log(...new Map([['a', '1'], ['b', '2']])); // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 });
// TypeError: Found non-callable @@iterator
```

**35-03Math 함수**3
```javascript
const arr = [1, 2, 3];

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.
//const max = Math.max(20, 1, 60);
const max = Math.max(...arr); //스프레드로 복사사용하면 max함수 사용이 가능하다.
console.log(max);
```

**35-13배열 삽입을 스프레드로 간결해게 사용하기**
```javascript
// ES6
const arr1 = [1, 4];
const arr2 = [2, 3];

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4]
```

**35-22 스프레드로 객체복사하는 방법 3가지 중요!!**
```javascript
// 객체 복사(얕은 복사)
// 객체 복사 3가지 방법 꼭 알아두기 중요!!
const obj = { x: 1, y: 2 };
const copy = { ...obj };
const copy2 = {x, y};
const copy3 = {x:1, y:2} 

console.log(copy); // { x: 1, y: 2 }

console.log(obj === copy); // false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }
```

**35-24 스프레드로 프로퍼티 수정**
```javascript
// 객체 병합. 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } };
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 };
// changed = { ...{ x: 1, y: 2 }, ...{ y: 100 } }
console.log(changed); // { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, y: 2 }, z: 0 };
// added = { ...{ x: 1, y: 2 }, ...{ z: 0 } }
console.log(added); // { x: 1, y: 2, z: 0 }
```

**디스트럭처링 할당 왼쪽 배열할당은 순서가 망가져도 알아서 디스트럭처링으로 할당된다.**
```javascript
 const obj = {a:1, b:2, c:3};
// 별명 을 줄수 있다.
 const {b : banana, c : k2, a} = obj; 

 console.log(a, banana, k2); // 1, 2, 3
```

**c는 객체이며 d1, d2를 중첩 디스트럭처링이 가능하다.**
```javascript
const obj = {a:1, b:2, c:{d1 : 100, d2 : 200}};
const {a, b, c:{d1, d2}} = obj; 

console.log(a, bm, d1, d2);
```

**36-17 변수 바로 뽑아 쓰기 많이 사용하는 예제**
```javascript
const str = 'Hello';
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5

const todo = { id: 1, content: 'HTML', completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

**시험!! url 구조**
![image](https://user-images.githubusercontent.com/56966606/172661082-ca4eb83c-fe2e-4a36-af92-0c762088e077.png)
**웹의 구조**
