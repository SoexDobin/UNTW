
* 자바스크립트가 하는 일
  - html, css 추가 삭제 변경
  - 원격 서버 요청
  - 사용자 이벤트 반응
  - 브라우저 안에서 데이터 읽고 쓰기
  + Node.exe 자바스크립트로 외부에서 작용

* 변수 선언 방식
  - var 
  - let (변수 정리)
  - const (상수 정리)

**암기하기★**
* 데이터 내장 타입 (단일 값)
  - 숫자타입 number
  - 문자열타입 string
  - 불린 boolen
  - undefined (초기화X)
  - null (값이 없다, 참조 제거)
  - symbol (유니크한 어떤 private값 == key)
  - bigint(컴퓨터가 인식하는 이상의 숫자)
* 객체 타입 (다양한 값)
  - object
**암기하기★**
* 정적 타입
  - 무조건 같은 타입만을 받음
  - char, string
* 동적 타입
  - ★동적 타입을 참조 형식으로 값을 할당함
  - 변수를 보고 타입을 판단 함
  - 가비지 컬렉터가 버려진 참조 형태의 변수를 알아서 제거해줌 
  - let, const, var

* 문 statement
  - ~문과 표현식으로 이루어짐
  - 초기화가 되는 변수가 있는 문은 표현식
  - 단지 아무것도 받지않고 선언만하면 문이라함 ex.함수문 var문

 * 형변환 
 ``` javascript
console.log("" + 1 + 0);    // "10"
console.log("" - 1 + 0);    // -1
console.log(true + false);  // 1
console.log(6 / "3");       // 2
console.log("2" * "3");     // 6
console.log(4 + 5 + "px");  // "9px"
console.log("$" + 4 + 5);   // $45
console.log("4" - 2);       // 2
console.log("4px" - 2);     // NaN★★★
console.log(7 / 0);         // Infinity★★★
console.log("  -9  " + 5);  // "  -9  5"
console.log("  -9  " - 5);  // -14
console.log(null + 1);      // 1
console.log(undefined + 1); // NaN
console.log(" \t \n" - 2);  // -2

let n = 10;
console.log(+n);            // 10
console.log(-n);            // -10
console.log(+Infinity);     // Infinity
console.log(-Infinity);     // -Infinity
console.log(+"10" + 1);     // 11★★★
console.log("10" * 1 + 1);  // 11★★★
 ```

 * 비교연산자
  - ++a 문장을 실행하며 증가 a++ 문장이 끝나고 난후 증가
  - == 값이 같은가?
  - === 값과 타입이 같은가?

* 3항 연산식
```javascript
var x = 2;

// 0은 false로 취급된다.
var result = x % 2 ? '홀수' : '짝수';
```
```javascript
var num = 2;

// 0은 false로 취급된다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';

console.log(kind); // 양수
```

* switch문
```javascript
// 월을 영어로 변환한다. (11 → 'November')
var month = 11;
var monthName;

switch (month) {
  case 1: monthName = 'January'; break;
  case 2: monthName = 'February'; break;
  case 3: monthName = 'March'; break;
  case 4: monthName = 'April'; break;
  case 5: monthName = 'May'; break;
  case 6: monthName = 'June'; break;
  case 7: monthName = 'July'; break;
  case 8: monthName = 'August'; break;
  case 9: monthName = 'September'; break;
  case 10: monthName = 'October'; break;
  case 11: monthName = 'November'; break;
  case 12: monthName = 'December'; break;
  default: monthName = 'Invalid month';
  case a: case: b case: c days = 30; break; //중복도 가능
}
console.log(monthName); // November
```
* for문
```javascript
// 무한루프
for (;;) { ... }

//중첩 for문
for (var i = 1; i <= 6; i++) {
  for (var j = 1; j <= 6; j++) {
    if (i + j === 6) console.log(`[${i}, ${j}]`);
  }
}
```

while문
```javascript
// 무한루프
while (true) {
  console.log(count);
  count++;
  if (count === 3) break; 
  // 타입과 값이 같으면
}

var count = 0;

// do while문 값이 false여도 무조건 1번 실행됨
// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.
// false 값이더라도 1번은 돌아감
var count = 10;
do {
  console.log(count);
  count++;
} while (count < 3);
//
```
foo레이블 식별자
```javascript
// foo라는 식별자가 붙은 레이블 블록문
foo: {
  console.log(1);
  break foo; // foo 레이블 블록문을 탈출한다.
  console.log(2); //실행 안됨!
}
```
foo를 outer라고 쓴것 뿐임 위에랑 같은 방식 탈출코드
```javascript
// outer라는 식별자가 붙은 레이블 for 문
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.
    if (i + j === 3) break outer;
    console.log(`inner [${i}, ${j}]`);
  }
}

console.log('Done!');
```
```javascript
var string = 'Hello World.';
var search = 'l';
var index;

// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.
for (var i = 0; i < string.length; i++) {
  // 문자열의 개별 문자가 'l'이면
  if (string[i] === search) {
    index = i;
    break; // 반복문을 탈출한다.
  }
}
console.log(index); // 2
//================================================================
// 참고로 String.prototype.indexOf 메서드를 사용해도 같은 동작을 한다.
console.log(string.indexOf(search)); // 2
```
console.log(String(string).indexOf(search)); 부모가 만들어놓은 객체
를 우리는 console.log(string.indexOf(search)); 이렇게 써서 불러오고
indexof메소드를 사용하게 된다.
**(.)연산자를 통한 멤버접근 래퍼객체**★★★

**String 생성자 함수 ★★**
```javascript
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
// 숫자 타입 => 문자열 타입
String(1);        // -> "1"
String(NaN);      // -> "NaN"
String(Infinity); // -> "Infinity"
// 불리언 타입 => 문자열 타입
String(true);     // -> "true"
String(false);    // -> "false"

// 2. Object.prototype.toString 메서드를 사용하는 방법
// 숫자 타입 => 문자열 타입
(1).toString();        // -> "1"
(NaN).toString();      // -> "NaN"
(Infinity).toString(); // -> "Infinity"
// 불리언 타입 => 문자열 타입
(true).toString();     // -> "true"
(false).toString();    // -> "false"

// 3. 문자열 연결 연산자를 이용하는 방법
// 숫자 타입 => 문자열 타입
1 + '';        // -> "1"
NaN + '';      // -> "NaN"
Infinity + ''; // -> "Infinity"
// 불리언 타입 => 문자열 타입
true + '';     // -> "true"
false + '';    // -> "false"
```
**Number 생성자 함수 ★★**
```javascript
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0');     // -> 0
Number('-1');    // -> -1
Number('10.53'); // -> 10.53
// 불리언 타입 => 숫자 타입
Number(true);    // -> 1
Number(false);   // -> 0

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
// 문자열 타입 => 숫자 타입
parseInt('0');       // -> 0 ★★
parseInt('-1');      // -> -1 ★★
parseFloat('10.53'); // -> 10.53 ★★

// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
+'0';     // -> 0
+'-1';    // -> -1
+'10.53'; // -> 10.53
// 불리언 타입 => 숫자 타입
+true;    // -> 1
+false;   // -> 0

// 4. * 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
'0' * 1;     // -> 0
'-1' * 1;    // -> -1
'10.53' * 1; // -> 10.53
// 불리언 타입 => 숫자 타입
true * 1;    // -> 1
false * 1;   // -> 0
```

**논리연산자★★★★★**
&& 단축평가
And연산자는 앞이false면 뒤를 확인 안함
|| 단락평가
or연산자는 앞이true면 뒤를 확인 안함
```javascript
"Cat" && "Dog" //-> "Dog"
"Cat" || "Dog" //-> "Cat"
```
**null통한 동적메모리 확인★★★**
```javascript
var elem = null;
// elem이 null이나 undefined와 같은 Falsy 값이면 elem으로 평가되고
// elem이 Truthy 값이면 elem.value로 평가된다.
var value = elem && elem.value; // -> null
//===================================================================
var elem = null;

// elem이 null 또는 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
var value = elem?.value;
console.log(value); // undefined
//===================================================================
// 좌항의 피연산자가 null 또는 undefined이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
var foo = null ?? 'default string';
console.log(foo); // "default string"
```
## 객체생성방법
  - 객체 리터럴
  - object생성자 함수
  - object.create()메서드
  - 사용자 생성자 함수
  - 클래스 사용하는 방법

**객체 리터럴**
```javascript
var person = {
  name: 'Lee',
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  }
};

console.log(typeof person); // object
console.log(person); // {name: "Lee", sayHello: ƒ}
//{ property key : property value }로 쓰면됨
// {} 리터럴 객체라고 함
// 함수를 객체로 가지게 되면 메서드라고 부름
```
* delete 소멸자
```javascript
var person = {
  name: 'Lee'
};

// 프로퍼티 동적 생성
person.age = 20;

// person 객체에 age 프로퍼티가 존재한다.
// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있다.
delete person.age;

// person 객체에 address 프로퍼티가 존재하지 않는다.
// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 없다. 이때 에러가 발생하지 않는다.
delete person.address;

console.log(person); // {name: "Lee"}
```

* **시험★★★★★**
```javascript
// ES5
var x = 1, y = 2; // value 부분
 
var obj1 = { x: x, y: y }; //key부분
var obj2 = { x, y };

console.log(obj1); // {x: 1, y: 2}
console.log(obj2); // {x: 1, y: 2} 익스6이상부터 지원
//key와 value가 같으면 생략을 통해 사용가능
```
* 템플릿 문자열
```javascript
const prefix = 'prop';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i };

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 원시값과 객체의 비교
**시험★★★★★**   

![원시 변수 값변경](https://user-images.githubusercontent.com/56966606/161897422-c31cb3d7-42a6-4ba0-8a56-76f14f2b737d.png)
* 변수 값 변경은 값이 갈아치워지는게 아닌 다른메모리에 할당된 변수로 주소가 참조 되는 것이다.

![shallow deep copy](https://user-images.githubusercontent.com/56966606/161899008-c31ebbe5-da53-403d-b2f4-0b8ced601b81.png)

**시험★★★★★**   
```javascript
const o = { x: { y: 1 } }; // 2번에 걸쳐 옅은복사 참조

// 얕은 복사
const c1 = { ...o }; 
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
// 스프레드 문법으로 객체 메모리가 복사되지만 또다른 프로퍼티가key 값으로 오면 한게를 마주한다.

// 깊은 복사
const c2 = JSON.parse(JSON.stringify(o));
console.log(c1 === c2);
console.log(c1.x === c2.x);
//JSON은 객체를 모두 string으로 바꿈
//parse는 JSON의string문자들을 다시 객체로 반환하는 역할
//복사가 아닌 JSON을 통해 똑같이 만드는 것일 뿐임으로 
// 값과 메모리 상태가 다르다.

// lodash의 cloneDeep을 사용한 깊은 복사
const _ = require('lodash');
// require은 lodash"모듈"을 가져오는 역할
// 깊은 복사
const c3 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
```
**결국 기본타입값이 같아야하고 객체는 참조가 같아야 한다.**
```javascript
var person = { name: 'Lee' };
// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

### 함수
**★★★함수 리터럴 표현식**
```javascript
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
* var f 선언이 붙고 ;로 객체로 취급한다
* add호출이 불가하고 add함수를 f로 선언하기로 약속한것이다.

**★★★그룹연산자사용으로 즉시함수식으로 변형**
```javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); })(); //즉시 실행 함수
bar(); // ReferenceError: bar is not defined
```
**생성자 함수**
```javascript
var add = new Function('x', 'y', 'console.log(x,y), return x + y');

console.log(add(2, 5)); // 7
```
**화살표 함수**
```javascript
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
**★★★scope!! outer와 inner 함수**
```javascript
function outer() {
  var x = 1;
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); 
    // x는 아우터의 지역변수, y는 inner의 지역변수
  } inner(); }
outer();
```
**시험!★★★callback 함수**
* 클라이언트가 기능을 서비스 코드에 삽입 가능하게하는 함수.
* 클라이언트가 가진 정책을 서비스코드에 반영 
```javascript
//Server Code
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); } } // i를 전달하면서 f를 호출
//Client Code
var logAll = function (i) {
  console.log(i);
};
repeat(5, logAll); //callback function구현
repeat(5, (n) -> console.log("+n"));
repeat(5, function(n){console.log(n,n,n);});
```
* 콜백 함수를 사용한 이벤트 처리
```javascript
document.getElementById('myButton').addEventListener('click', function () {
  console.log('button clicked!');
});

// 콜백 함수를 사용한 비동기 처리
setTimeout(function () {
  console.log('1초 경과');
}, 1000);
```
* 고차함수 3가지
```javascript
var res = [1, 2, 3].map(function (item) {
  return item * 2; });
console.log(res); // [2, 4, 6]

res = [1, 2, 3].filter(function (item) {
  return item % 2; });
console.log(res); // [1, 3]

res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur; }, 0);
console.log(res); // 6
```
* map과 filter는 배열 생성 reduce는 단 1개의 값만 생성   
* 순수 함수
```javascript
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.
// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}
// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1
```
* 비순수 함수
```javascript
var count = 0; 
// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}
// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1
```
### Scope
* Scope란 우리말로 '범위' 변수에 접근 할 수있는 유효범위라고 한다.
* 자스 스코프는 2가지 타입이 있다 바로 global(전역)과 local(지역)

```javascript
var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수

if (true) {
  var var2 = 2; // 코드 블록 내에서 선언한 변수
  if (true) {
    var var3 = 3; // 중첩된 코드 블록 내에서 선언한 변수
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언한 변수

  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언한 변수
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```
* 전역 변수로써 var는 활용되지만 함수안에서는 함수로써 변수로만 활동한다.
* 함수범위로써의 변수라고 한다. 함수이외는 전부 전역 변수 if else등 무시.

* const 확실히 사용에 대문자를 이용해 표현 
```javascript
const Tax = 0.1;
```
**중요!!!!!**
* 일반 cosnt는 값 변경이 불가능하다.
* 그러나 const 참조 객체는 참조값의 값 변경이 가능하다!
```javascript
const person = {
  name: 'Lee'
};

// 객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.
person.name = 'Kim';

console.log(person); // {name: "Kim"}
```
### 객체의 속성 
* 객체에는 여러 속성을 가질 수 있음 함수, 값 등
```javascript
/ 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
person.sayHello = function () {
  console.log('Hi! My name is ' + this.name); 
};
console.log(person); // {name: "Lee", sayHello: ƒ}
person.sayHello(); // Hi! My name is Lee
```
**프로토 타입 객체!! 시험**
* 자바스크립트 자체 내부에서 사용하는 엔진 구조
 - 내부 슬롯
  + 프로퍼티
  + 메소드
```javascript
const o = {};

// 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다.
o.[[Prototype]] // -> Uncaught SyntaxError: Unexpected token '['
// 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.
o.__proto__ // -> Object.prototype
```
* 모든 객체는 Prototpye이라는 요소를 가진다. [[Prototype]]
  - __proto__  [[Prototype]]의 접근자속성라고하고 이렇게 사용한다.
  - __proto__ 객체는 또한 getter, setter 라는 access속성을 가짐
```javascript
const person = {
  name: 'Lee'
};
person.age = 20;
console.log(Object.getOwnPropertyDescriptor(person));
// Object는 생성자의 메서드!! 
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
// 중요한 점은 이 메서드는 단 1개만 존재하는 클래스로써 여러 사용이 불가함.
```
![prototype1](https://user-images.githubusercontent.com/56966606/162617815-1dd6b541-1604-49e3-befb-3fb267497a1b.png)
* 모든 생성자함수만이 prototype속성을 가지고 있다.
* 생성자 함수가 가진 prototype 속성을 이용하여 최상위 부모객체가 존재하게 된다.
* 최상위 부모객체(object.prototype)는 Prototype속성을 가지지 않는다.
* 생성자 함수와 다른 객체요소는 이 프로토타입에 의존한다.
* 생성자 함수&부모객체를 제외한 의존 객체는 모두 prototype을 가진다.
* 프로토타입에 의해 만들어진 객체는 __p__로 참조가능하다.
```javascript
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 인스턴스의 생성
const circle1 = new Circle(5);  // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```




```javascript
function Circle(radius) {
  // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.

  // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };

  // 3. 암묵적으로 this를 반환한다.
  // 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.
  return 100;
}

// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.
const circle = new Circle(1);
console.log(circle); // Circle {radius: 1, getDiameter: ƒ}
```


```javascript
function foo() {}

// 일반적인 함수로서 호출: [[Call]]이 호출된다.
foo();

// 생성자 함수로서 호출: [[Construct]]가 호출된다.
new foo();
```

```javascript
// 일반 함수 정의: 함수 선언문, 함수 표현식
function foo() {}
const bar = function () {};
// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.
const baz = {
  x: function () {}
};

// 일반 함수로 정의된 함수만이 constructor이다.
new foo();   // -> foo {}
new bar();   // -> bar {}
new baz.x(); // -> x {}

// 화살표 함수 정의
const arrow = () => {};

new arrow(); // TypeError: arrow is not a constructor

// 메서드 정의: ES6의 메서드 축약 표현만을 메서드로 인정한다.
const obj = {
  x() {}
};

new obj.x(); // TypeError: obj.x is not a constructor
```

* console.dir 
 + 단 1개의 객채만을 출력하기 위한 코드
```javascript
function square(number) {
  return number * number;
}
console.dir(square);
// 객체 정보를 출력한다.
```
**객체 Object의 프로토타입**
```javascript
function square(number) {
  return number * number;
}

console.log(Object.getOwnPropertyDescriptors(square));
/*
{
  length: {value: 1, writable: false, enumerable: false, configurable: true},
  name: {value: "square", writable: false, enumerable: false, configurable: true},
  arguments: {value: null, writable: false, enumerable: false, configurable: false},
  caller: {value: null, writable: false, enumerable: false, configurable: false},
  prototype: {value: {...}, writable: true, enumerable: false, configurable: false}
}
*/

// __proto__는 square 함수의 프로퍼티가 아니다.
console.log(Object.getOwnPropertyDescriptor(square, '__proto__')); // undefined

// __proto__는 Object.prototype 객체의 접근자 프로퍼티다.
// square 함수는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}
```

* 유사배열& iterator
 + 자바스크립트는 여러개의 개체를 참조 할수있다.
 + 유사배열 객체는 length프로퍼티와 []연산자등 배열관련 요소를 가지고있다.
 + 객체.[Symbol.iterator]();라고 이터러블 선언을 할 수 있다.
* 배열 객체
```javascript
unction sum() {
  // arguments 객체를 배열로 변환
  const array = Array.prototype.slice.call(arguments);
  return array.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}
console.log(sum(1, 2));          // 3
console.log(sum(1, 2, 3, 4, 5)); // 15
```
* 중요한 점은 Array생성자 함수 의 프로토타입의 slice기능을 사용 할 수있다는 것.
* 자스는 논리적으로 slice기능을 자시 객체가 자기것인 것처럼 쓸 수 있다.

**객체 프로토타입 프로퍼티 확인**
```javascript
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log(obj.__proto__ === Object.prototype); // true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다.
console.log(obj.hasOwnProperty('a'));         // true
console.log(obj.hasOwnProperty('__proto__')); // false
```

```javascript
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```